<?xml version="1.0" encoding="utf-8"?>
<pex id="{39bd6b65-0bf5-405e-9378-653eadb82fa6}" creationTime="2015-11-27 23:30:26Z" configuration="Benchmarks!\FixedSizeStackTest!\*" created="2015-11-27 23:30:26Z" pexVersion="0.94.51006.1" xml="C:\Users\vagrant\Downloads\CovanaReleaseV0.1\Covana\Benchmarks\bin\Debug\reports\151127.153026.2652.pex\report.per" html="C:\Users\vagrant\Downloads\CovanaReleaseV0.1\Covana\Benchmarks\bin\Debug\reports\151127.153026.2652.pex\report.html"><environment commandLine="&quot;C:\Program Files (x86)\Microsoft Pex\bin\Microsoft.Pex.x86.exe&quot; C:\Users\vagrant\Downloads\CovanaReleaseV0.1\Covana\Benchmarks\bin\Debug\Benchmarks.dll /namespacefilter:Benchmarks! /typefilter:FixedSizeStackTest! /targetx86 /x64failsilently /clrversion:v4.0.30319 /referencedprojectassemblies:ExternalLib;Covana /donotopenreport /reportlevel:Xml /reportrootpath:C:\Users\vagrant\Downloads\CovanaReleaseV0.1\Covana\Benchmarks\bin\Debug\reports /testframework:VisualStudioUnitTest /testlanguage:cs /testprojectfile:C:\Users\vagrant\Downloads\CovanaReleaseV0.1\Covana\Benchmarks\Benchmarks.csproj /testprojectnotupdate /testprojectskip" machineName="Client" osVersion="Microsoft Windows NT 6.1.7601 Service Pack 1" processorCount="2" clrVersion="4.0.30319.34209" bitness="x86" user="vagrant"><envVars><envVar name="HOMEPATH" value="\Users\vagrant"/>
<envVar name="COMPUTERNAME" value="Client"/>
<envVar name="CLRMONITOR_INJECT_TYPES" value=""/>
<envVar name="CommonProgramFiles(x86)" value="C:\Program Files (x86)\Common Files"/>
<envVar name="PROCESSOR_IDENTIFIER" value="Intel64 Family 6 Model 69 Stepping 1, GenuineIntel"/>
<envVar name="SESSIONNAME" value="Console"/>
<envVar name="CYGWIN" value="mintty"/>
<envVar name="TMP" value="C:\Users\vagrant\AppData\Local\Temp"/>
<envVar name="PROCESSOR_REVISION" value="4501"/>
<envVar name="CLRMONITOR_INSTRUMENT_TYPES_EXCLUSIONS" value=""/>
<envVar name="PATHEXT" value=".COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC"/>
<envVar name="VS100COMNTOOLS" value="C:\Program Files (x86)\Microsoft Visual Studio 10.0\Common7\Tools\"/>
<envVar name="COMPLUS_DEFAULTVERSION" value="v4.0.30319"/>
<envVar name="CLRMONITOR_CLSID" value="{21bbb412-71ac-41f9-a377-48529a4859cf}"/>
<envVar name="SystemDrive" value="C:"/>
<envVar name="PROCESSOR_LEVEL" value="6"/>
<envVar name="TEMP" value="C:\Users\vagrant\AppData\Local\Temp"/>
<envVar name="LOCALAPPDATA" value="C:\Users\vagrant\AppData\Local"/>
<envVar name="PUBLIC" value="C:\Users\Public"/>
<envVar name="CLRMONITOR_PROTECT_ALL_CCTORS" value="1"/>
<envVar name="CLRMONITOR_PROTECT_TYPES" value="Microsoft.FSharp.Text.Printf,Microsoft.FSharp.Text.PrintfImpl"/>
<envVar name="CLRMONITOR_INITIALIZED" value="0xe"/>
<envVar name="USERDOMAIN" value="Client"/>
<envVar name="ComSpec" value="C:\Windows\system32\cmd.exe"/>
<envVar name="CLRMONITOR_ERASE_FINALIZER_TYPES" value=""/>
<envVar name="CLRMONITOR_INJECT_NAMESPACES" value=""/>
<envVar name="NUMBER_OF_PROCESSORS" value="2"/>
<envVar name="CommonProgramFiles" value="C:\Program Files (x86)\Common Files"/>
<envVar name="ProgramFiles(x86)" value="C:\Program Files (x86)"/>
<envVar name="CLRMONITOR_INSTRUMENT_NAMESPACES_EXCLUSIONS" value=""/>
<envVar name="CLRMONITOR_FLAGS" value=""/>
<envVar name="VisualStudioDir" value="C:\Users\vagrant\Documents\Visual Studio 2010"/>
<envVar name="pex_instrumentation" value="1"/>
<envVar name="CLRMONITOR_INSTRUMENT_TYPES" value="System.Array,System.Array+ArrayEnumerator,System.Array+FunctorComparer`1,System.Array+SZArrayEnumerator,System.Array+SorterGenericArray,System.Array+SorterObjectArray,System.Boolean,System.Byte,System.Char,System.CharEnumerator,System.ComponentModel.Component,System.ComponentModel.Container,System.ComponentModel.Container+Site,System.Convert,System.Currency,System.DateTime,System.Decimal,System.Diagnostics.Assert,System.Double,System.Globalization.CharUnicodeInfo,System.Globalization.CultureTableRecord,System.Globalization.TextInfo,System.Guid,System.IO.MemoryStream,System.IO.Stream,System.IO.StreamReader,System.IO.StreamWriter,System.IO.StringReader,System.IO.StringWriter,System.Int16,System.Int32,System.Int64,System.Lazy`1,System.Lazy`1+Boxed,System.Lazy`1+LazyInternalExceptionHolder,System.Math,System.Nullable,System.Nullable`1,System.OrdinalComparer,System.SByte,System.SZArrayHelper,System.SZArrayHelper+SZGenericArrayEnumerator`1,System.Single,System.String,System.StringComparer,System.Text.ASCIIEncoding,System.Text.DecoderNLS,System.Text.Encoding,System.Text.UTF8Encoding,System.TimeSpan,System.Tuple,System.Tuple`1,System.Tuple`2,System.Tuple`3,System.Tuple`4,System.Tuple`5,System.Tuple`6,System.Tuple`7,System.Tuple`8,System.UInt16,System.UInt32,System.UInt64,System.Xml.XmlTextWriter,System.Xml.XmlTextWriter+Namespace,System.Xml.XmlTextWriter+NamespaceState,System.Xml.XmlTextWriter+SpecialAttr,System.Xml.XmlTextWriter+State,System.Xml.XmlTextWriter+TagInfo,System.Xml.XmlTextWriter+Token,System.Xml.XmlWriter,System.Xml.XmlWriter+&lt;WriteAttributeStringAsyncHelper&gt;d__0,System.Xml.XmlWriter+&lt;WriteAttributesAsync&gt;d__7,System.Xml.XmlWriter+&lt;WriteElementStringAsync&gt;d__20,System.Xml.XmlWriter+&lt;WriteLocalNamespacesAsync&gt;d__23,System.Xml.XmlWriter+&lt;WriteNodeAsync&gt;d__19,System.Xml.XmlWriter+&lt;WriteNodeAsync_CallAsyncReader&gt;d__10,System.Xml.XmlWriter+&lt;WriteNodeAsync_CallSyncReader&gt;d__a,System.Xml.XmlWriter+&lt;WriteQualifiedNameAsync&gt;d__3,__Box`1,__SzArrayHelper`1"/>
<envVar name="ProgramData" value="C:\ProgramData"/>
<envVar name="ProgramW6432" value="C:\Program Files"/>
<envVar name="ProgramFiles" value="C:\Program Files (x86)"/>
<envVar name="CLRMONITOR_ERASE_CCTOR_TYPES" value=""/>
<envVar name="FP_NO_HOST_CHECK" value="NO"/>
<envVar name="pex_clientid" value="pex2632_1"/>
<envVar name="windir" value="C:\Windows"/>
<envVar name="SystemRoot" value="C:\Windows"/>
<envVar name="CLRMONITOR_INSTRUMENT_ATTRIBUTE" value="Microsoft.Moles.Framework.Moles.MolesInstrumentAttribute"/>
<envVar name="COMPLUS_ProfAPI_ProfilerCompatibilitySetting" value="EnableV2Profiler"/>
<envVar name="pex_server_channel" value="pex2632"/>
<envVar name="CommonProgramW6432" value="C:\Program Files\Common Files"/>
<envVar name="PROCESSOR_ARCHITEW6432" value="AMD64"/>
<envVar name="LOGONSERVER" value="\\Client"/>
<envVar name="USERPROFILE" value="C:\Users\vagrant"/>
<envVar name="CLRMONITOR_SUBSTITUTIONS" value="C:\Windows\assembly\GAC_MSIL\Microsoft.ExtendedReflection\0.94.0.0__31bf3856ad364e35\Microsoft.ExtendedReflection.dll"/>
<envVar name="APPDATA" value="C:\Users\vagrant\AppData\Roaming"/>
<envVar name="HOMEDRIVE" value="C:"/>
<envVar name="CLRMONITOR_INJECT_ASSEMBLIES" value=""/>
<envVar name="PSModulePath" value="C:\Windows\system32\WindowsPowerShell\v1.0\Modules\"/>
<envVar name="USERNAME" value="vagrant"/>
<envVar name="COR_PROFILER" value="{21bbb412-71ac-41f9-a377-48529a4859cf}"/>
<envVar name="PROCESSOR_ARCHITECTURE" value="x86"/>
<envVar name="CLRMONITOR_INSTRUMENT_ASSEMBLIES_EXCLUSIONS" value=""/>
<envVar name="OS" value="Windows_NT"/>
<envVar name="CLRMONITOR_INSTRUMENT_NAMESPACES" value="System.Collections,System.Collections.Generic,System.Collections.ObjectModel,System.Collections.Specialized,System.Diagnostics.Contracts"/>
<envVar name="Path" value="C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;C:\Program Files\OpenSSH\bin;C:\Windows\System32\WindowsPowerShell\v1.0\;c:\Program Files (x86)\Microsoft SQL Server\100\Tools\Binn\;c:\Program Files\Microsoft SQL Server\100\Tools\Binn\;c:\Program Files\Microsoft SQL Server\100\DTS\Binn\"/>
<envVar name="CLRMONITOR_INSTRUMENT_ASSEMBLIES" value="Benchmarks,ExternalLib,ExternalLib2,ExternalLib;Covana,FSharp.Core,FSharp.PowerPack,Microsoft.Contracts,Microsoft.VisualBasic,Microsoft.VisualStudio.QualityTools.UnitTestFramework,System,System.Core,System.Web"/>
<envVar name="ALLUSERSPROFILE" value="C:\ProgramData"/>
</envVars>
</environment>
<settings/>
<reflection/>
<assembly name="Benchmarks" version="1.0.0.0" fileVersion="1.0.0.0" fullName="Benchmarks, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null" location="C:\Users\vagrant\Downloads\CovanaReleaseV0.1\Covana\Benchmarks\bin\Debug\Benchmarks.dll" fileName="Benchmarks.dll"><settings testFramework="VisualStudioUnitTest" testLanguage="cs"/>
<fixture name="FixedSizeStackTest" type="Benchmarks.FixedSizeStackTest" typeName="FixedSizeStackTest" token="2000004" href="fix\Benchmarks.97.html"><type spec="Class"><definition assemblyName="Benchmarks" name="FixedSizeStackTest" token="2000004" namespace="Benchmarks"/>
</type>
<settings typeUnderTest="Benchmarks.FixedSizeStack"/>
<exploration shortName="TestPush(FixedSizeStack, Object)" fullName="Benchmarks.FixedSizeStackTest.TestPush(FixedSizeStack, Object)"><method><definition assemblyName="Benchmarks" name="TestPush" token="6000007"><declaringType assemblyName="Benchmarks" name="FixedSizeStackTest" token="2000004" namespace="Benchmarks"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Benchmarks" name="FixedSizeStackTest" token="2000004" namespace="Benchmarks"/>
</type>
</parameter>
<parameter name="stack" position="1"><type spec="Class"><definition assemblyName="Benchmarks" name="FixedSizeStack" token="2000003" namespace="Benchmarks"/>
</type>
</parameter>
<parameter name="item" position="2"><type spec="Class"><definition assemblyName="mscorlib" name="Object" token="2000002" namespace="System"/>
</type>
</parameter>
</definition>
</method>
<memberUnderTest assemblyName="Benchmarks" name="Push" token="6000006"><declaringType assemblyName="Benchmarks" name="FixedSizeStack" token="2000003" namespace="Benchmarks"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Benchmarks" name="FixedSizeStack" token="2000003" namespace="Benchmarks"/>
</type>
</parameter>
<parameter name="item" position="1"><type spec="Class"><definition assemblyName="mscorlib" name="Object" token="2000002" namespace="System"/>
</type>
</parameter>
</memberUnderTest>
<log level="error" time="2015-11-27 23:30:29Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to open"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<log level="message" time="2015-11-27 23:30:29Z" category="symbols" message="could not load symbols for C:\Windows\Microsoft.Net\assembly\GAC_MSIL\Microsoft.VisualBasic\v4.0_10.0.0.0__b03f5f7f11d50a3a\Microsoft.VisualBasic.dll"/>
<log level="message" time="2015-11-27 23:30:29Z" category="symbols" message="search path: ;"/>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:29Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to rollback"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<test name="TestPush" state="success" duration="0.21"/>
<log level="error" time="2015-11-27 23:30:29Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to open"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:29Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to rollback"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:29Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to open"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:29Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to rollback"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:29Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to open"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:29Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to rollback"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<generatedTest id="024e3411-250b-41cd-9920-99c08549cf2e" index="1" run="1" exceptionState="unexpected" status="exception" failed="true" generated="true" new="true" assemblyName="Benchmarks" name="TestPushThrowsNullReferenceException889"><declaringType assemblyName="Benchmarks" name="FixedSizeStackTest" token="ffffffff" namespace="Benchmarks"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Benchmarks" name="FixedSizeStackTest" token="ffffffff" namespace="Benchmarks"/>
</type>
</parameter>
<rcov name="Block" dcov="0" dtot="0" acov="0" atot="0"/>
<rcov name="asserts" dcov="0" dtot="0" acov="0" atot="0"/>
<value name="stack">null</value>
<value name="item">null</value>
<code><![CDATA[this.TestPush((FixedSizeStack)null, (object)null);
]]></code>
<methodCode imports="Microsoft.VisualStudio.TestTools.UnitTesting;Microsoft.Pex.Framework.Generated;System"><![CDATA[[TestMethod]
[PexGeneratedBy(typeof(FixedSizeStackTest))]
[PexRaisedException(typeof(NullReferenceException))]
public void TestPushThrowsNullReferenceException889()
{
    this.TestPush((FixedSizeStack)null, (object)null);
}
]]></methodCode>
<reference name="Microsoft.VisualStudio.QualityTools.UnitTestFramework"/>
<reference name="mscorlib" location="C:\Windows\Microsoft.NET\Framework\v4.0.30319\mscorlib.dll"/>
<reference name="Microsoft.Pex.Framework"/>
<reference name="Benchmarks" location="C:\Users\vagrant\Downloads\CovanaReleaseV0.1\Covana\Benchmarks\bin\Debug\Benchmarks.dll"/>
<exceptionChain><exception typeDisplayName="NullReferenceException" source="Benchmarks"><message><![CDATA[Object reference not set to an instance of an object.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="NullReferenceException" token="2000111" namespace="System"/>
</type>
<stackTrace><frame value="  at FixedSizeStackTest.TestPush(FixedSizeStack, Object) in C:\Users\vagrant\Downloads\CovanaReleaseV0.1\Covana\Benchmarks\FixedSizeStackTest.cs(66)" method="FixedSizeStackTest.TestPush(FixedSizeStack, Object)" offset="1" file="C:\Users\vagrant\Downloads\CovanaReleaseV0.1\Covana\Benchmarks\FixedSizeStackTest.cs" line="66"><method assemblyName="Benchmarks" name="TestPush" token="6000007"><declaringType assemblyName="Benchmarks" name="FixedSizeStackTest" token="2000004" namespace="Benchmarks"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Benchmarks" name="FixedSizeStackTest" token="2000004" namespace="Benchmarks"/>
</type>
</parameter>
<parameter name="stack" position="1"><type spec="Class"><definition assemblyName="Benchmarks" name="FixedSizeStack" token="2000003" namespace="Benchmarks"/>
</type>
</parameter>
<parameter name="item" position="2"><type spec="Class"><definition assemblyName="mscorlib" name="Object" token="2000002" namespace="System"/>
</type>
</parameter>
</method>
<beforeSource><![CDATA[        [PexMethod]
        public void TestPush(FixedSizeStack stack, object item)
        {]]></beforeSource>
<source><![CDATA[            stack.Push(item);]]></source>
<afterSource><![CDATA[        }
    }
}]]></afterSource>
</frame>
</stackTrace>
</exception>
</exceptionChain>
<fix rank="5" testid="024e3411-250b-41cd-9920-99c08549cf2e" kind="precondition" shortMethodNameWithParameters="FixedSizeStackTest.TestPush(FixedSizeStack, Object)" imports="Microsoft.ExtendedReflection.Collections.SafeSet`1[System.String]"><reference name="Microsoft.Pex.Framework"/>
<reference name="mscorlib"/>
<reference name="Microsoft.ExtendedReflection"/>
<method><definition assemblyName="Benchmarks" name="TestPush" token="6000007"><declaringType assemblyName="Benchmarks" name="FixedSizeStackTest" token="2000004" namespace="Benchmarks"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Benchmarks" name="FixedSizeStackTest" token="2000004" namespace="Benchmarks"/>
</type>
</parameter>
<parameter name="stack" position="1"><type spec="Class"><definition assemblyName="Benchmarks" name="FixedSizeStack" token="2000003" namespace="Benchmarks"/>
</type>
</parameter>
<parameter name="item" position="2"><type spec="Class"><definition assemblyName="mscorlib" name="Object" token="2000002" namespace="System"/>
</type>
</parameter>
</definition>
</method>
<code><![CDATA[PexAssume.IsNotNull((object)stack, "stack");
]]></code>
</fix>
<pathCondition><![CDATA[return stack == (FixedSizeStack)null;
]]></pathCondition>
</generatedTest>
<log level="error" time="2015-11-27 23:30:30Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to open"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<explorable title="guessed how to create Benchmarks.FixedSizeStack" kind="guessedclass" isExplorableTypeExported="true"><explorableType spec="Class"><definition assemblyName="Benchmarks" name="FixedSizeStack" token="2000003" namespace="Benchmarks"/>
</explorableType>
<testAssemblyName name="Benchmarks"/>
<update kind="CollectionCodeUpdate" name="Accept/Edit Factory"><codeUpdate kind="AddTypeCodeUpdate" name="Add type" fileNameHint="Factories\FixedSizeStackFactory" abstract="true" sealed="true" visibility="Public"><doc><![CDATA[<summary>A factory for Benchmarks.FixedSizeStack instances</summary>
]]></doc>
<reference name="mscorlib"/>
<reference name="Microsoft.Pex.Framework"/>
<reference name="Benchmarks" location="C:\Users\vagrant\Downloads\CovanaReleaseV0.1\Covana\Benchmarks\bin\Debug\Benchmarks.dll"/>
<typeDefinition assemblyName="Benchmarks" name="FixedSizeStackFactory" token="ffffffff" namespace="Benchmarks"/>
<baseType spec="Class"><definition assemblyName="mscorlib" name="Object" token="2000002" namespace="System"/>
</baseType>
<target><assembly name="Benchmarks"/>
</target>
</codeUpdate>
<codeUpdate kind="AddMethodCodeUpdate" name="Add method" visibility="Public"><attribute><ctor><definition assemblyName="Microsoft.Pex.Framework" name=".ctor" token="6000e46"><declaringType assemblyName="Microsoft.Pex.Framework" name="PexFactoryMethodAttribute" token="200027d" namespace="Microsoft.Pex.Framework"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.Pex.Framework" name="PexFactoryMethodAttribute" token="200027d" namespace="Microsoft.Pex.Framework"/>
</type>
</parameter>
<parameter name="factoredType" position="1"><type spec="Class"><definition assemblyName="mscorlib" name="Type" token="200012b" namespace="System"/>
</type>
</parameter>
</definition>
</ctor>
<ctorArgument><value kind="TypeOfExpression"><type spec="Class"><definition assemblyName="Benchmarks" name="FixedSizeStack" token="2000003" namespace="Benchmarks"/>
</type>
</value>
</ctorArgument>
</attribute>
<doc><![CDATA[<summary>A factory for Benchmarks.FixedSizeStack instances</summary>
]]></doc>
<reference name="Benchmarks" location="C:\Users\vagrant\Downloads\CovanaReleaseV0.1\Covana\Benchmarks\bin\Debug\Benchmarks.dll"/>
<reference name="mscorlib"/>
<methodDefinition assemblyName="Benchmarks" name="Create" static="true"><declaringType assemblyName="Benchmarks" name="FixedSizeStackFactory" token="ffffffff" namespace="Benchmarks"/>
<parameter name="stack_stack" position="0"><type spec="Class"><definition assemblyName="Benchmarks" name="Stack" token="2000002" namespace="Benchmarks"/>
</type>
</parameter>
<resultType spec="Class"><definition assemblyName="Benchmarks" name="FixedSizeStack" token="2000003" namespace="Benchmarks"/>
</resultType>
</methodDefinition>
<target><typeDefinition assemblyName="Benchmarks" name="FixedSizeStackFactory" token="ffffffff" namespace="Benchmarks"/>
</target>
</codeUpdate>
<codeUpdate kind="SelectCodeUpdate" name="Select" selectKind="Body"><target><methodDefinition assemblyName="Benchmarks" name="Create" static="true"><declaringType assemblyName="Benchmarks" name="FixedSizeStackFactory" token="ffffffff" namespace="Benchmarks"/>
<parameter name="stack_stack" position="0"><type spec="Class"><definition assemblyName="Benchmarks" name="Stack" token="2000002" namespace="Benchmarks"/>
</type>
</parameter>
<resultType spec="Class"><definition assemblyName="Benchmarks" name="FixedSizeStack" token="2000003" namespace="Benchmarks"/>
</resultType>
</methodDefinition>
</target>
</codeUpdate>
</update>
</explorable>
<log level="error" time="2015-11-27 23:30:30Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to rollback"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<test name="TestPush" state="success" duration="0.07"/>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStackTest.TestPush at 0x&lt;unknown offset&gt;"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[return stack != (FixedSizeStack)null;

Feasible prefixes:
return stack.GetType() != typeof(FixedSizeStack);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<log level="error" time="2015-11-27 23:30:30Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to open"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:30Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to rollback"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<test name="TestPush" state="success" duration="0.12"/>
<log level="error" time="2015-11-27 23:30:30Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to open"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:30Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to rollback"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:30Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to open"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:30Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to rollback"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:30Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to open"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:30Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to rollback"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:31Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to open"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:31Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to rollback"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:31Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to open"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:31Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to rollback"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:31Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to open"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:31Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to rollback"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:31Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to open"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:31Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to rollback"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<generatedTest id="dbff3083-51c1-48f8-ba7e-ec2e2a3419e7" index="2" run="3" exceptionState="unexpected" status="exception" failed="true" generated="true" new="true" assemblyName="Benchmarks" name="TestPushThrowsNullReferenceException238"><declaringType assemblyName="Benchmarks" name="FixedSizeStackTest" token="ffffffff" namespace="Benchmarks"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Benchmarks" name="FixedSizeStackTest" token="ffffffff" namespace="Benchmarks"/>
</type>
</parameter>
<rcov name="Block" dcov="1" dtot="8" acov="1" atot="8"/>
<rcov name="asserts" dcov="0" dtot="0" acov="0" atot="0"/>
<value name="stack">new FixedSizeStack{}</value>
<value name="item">null</value>
<code><![CDATA[FixedSizeStack fixedSizeStack;
fixedSizeStack = new FixedSizeStack((Stack)null);
this.TestPush(fixedSizeStack, (object)null);
]]></code>
<methodCode imports="Microsoft.VisualStudio.TestTools.UnitTesting;Microsoft.Pex.Framework.Generated;System"><![CDATA[[TestMethod]
[PexGeneratedBy(typeof(FixedSizeStackTest))]
[PexRaisedException(typeof(NullReferenceException))]
public void TestPushThrowsNullReferenceException238()
{
    FixedSizeStack fixedSizeStack;
    fixedSizeStack = new FixedSizeStack((Stack)null);
    this.TestPush(fixedSizeStack, (object)null);
}
]]></methodCode>
<reference name="Microsoft.VisualStudio.QualityTools.UnitTestFramework"/>
<reference name="mscorlib" location="C:\Windows\Microsoft.NET\Framework\v4.0.30319\mscorlib.dll"/>
<reference name="Microsoft.Pex.Framework"/>
<reference name="Benchmarks" location="C:\Users\vagrant\Downloads\CovanaReleaseV0.1\Covana\Benchmarks\bin\Debug\Benchmarks.dll"/>
<exceptionChain><exception typeDisplayName="NullReferenceException" source="Benchmarks"><message><![CDATA[Object reference not set to an instance of an object.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="NullReferenceException" token="2000111" namespace="System"/>
</type>
<stackTrace><frame value="  at FixedSizeStack.Push(Object) in C:\Users\vagrant\Downloads\CovanaReleaseV0.1\Covana\Benchmarks\FixedSizeStackTest.cs(51)" method="FixedSizeStack.Push(Object)" offset="1" file="C:\Users\vagrant\Downloads\CovanaReleaseV0.1\Covana\Benchmarks\FixedSizeStackTest.cs" line="51"><method assemblyName="Benchmarks" name="Push" token="6000006"><declaringType assemblyName="Benchmarks" name="FixedSizeStack" token="2000003" namespace="Benchmarks"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Benchmarks" name="FixedSizeStack" token="2000003" namespace="Benchmarks"/>
</type>
</parameter>
<parameter name="item" position="1"><type spec="Class"><definition assemblyName="mscorlib" name="Object" token="2000002" namespace="System"/>
</type>
</parameter>
</method>
<beforeSource><![CDATA[
        public void Push(object item)
        {]]></beforeSource>
<source><![CDATA[            if (stack.Count == 10)]]></source>
<afterSource><![CDATA[            {
                throw new Exception("full");
            }]]></afterSource>
</frame>
<frame value="  at FixedSizeStackTest.TestPush(FixedSizeStack, Object) in C:\Users\vagrant\Downloads\CovanaReleaseV0.1\Covana\Benchmarks\FixedSizeStackTest.cs(66)" method="FixedSizeStackTest.TestPush(FixedSizeStack, Object)" offset="1" file="C:\Users\vagrant\Downloads\CovanaReleaseV0.1\Covana\Benchmarks\FixedSizeStackTest.cs" line="66"><method assemblyName="Benchmarks" name="TestPush" token="6000007"><declaringType assemblyName="Benchmarks" name="FixedSizeStackTest" token="2000004" namespace="Benchmarks"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Benchmarks" name="FixedSizeStackTest" token="2000004" namespace="Benchmarks"/>
</type>
</parameter>
<parameter name="stack" position="1"><type spec="Class"><definition assemblyName="Benchmarks" name="FixedSizeStack" token="2000003" namespace="Benchmarks"/>
</type>
</parameter>
<parameter name="item" position="2"><type spec="Class"><definition assemblyName="mscorlib" name="Object" token="2000002" namespace="System"/>
</type>
</parameter>
</method>
<beforeSource><![CDATA[        [PexMethod]
        public void TestPush(FixedSizeStack stack, object item)
        {]]></beforeSource>
<source><![CDATA[            stack.Push(item);]]></source>
<afterSource><![CDATA[        }
    }
}]]></afterSource>
</frame>
</stackTrace>
</exception>
</exceptionChain>
<fix rank="65" testid="dbff3083-51c1-48f8-ba7e-ec2e2a3419e7" kind="precondition" shortMethodNameWithParameters="FixedSizeStack..ctor(Stack)" imports="Microsoft.ExtendedReflection.Collections.SafeSet`1[System.String]"><reference name="mscorlib"/>
<method><definition assemblyName="Benchmarks" name=".ctor" token="6000005"><declaringType assemblyName="Benchmarks" name="FixedSizeStack" token="2000003" namespace="Benchmarks"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Benchmarks" name="FixedSizeStack" token="2000003" namespace="Benchmarks"/>
</type>
</parameter>
<parameter name="stack" position="1"><type spec="Class"><definition assemblyName="Benchmarks" name="Stack" token="2000002" namespace="Benchmarks"/>
</type>
</parameter>
</definition>
</method>
<code><![CDATA[if (stack == (Stack)null)
  throw new ArgumentNullException("stack");
]]></code>
</fix>
<fix rank="20" testid="dbff3083-51c1-48f8-ba7e-ec2e2a3419e7" kind="invariant" shortMethodNameWithParameters="FixedSizeStack.Push(Object)" imports="Microsoft.ExtendedReflection.Collections.SafeSet`1[System.String]"><reference name="System"/>
<reference name="mscorlib"/>
<method><definition assemblyName="Benchmarks" name="Push" token="6000006"><declaringType assemblyName="Benchmarks" name="FixedSizeStack" token="2000003" namespace="Benchmarks"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Benchmarks" name="FixedSizeStack" token="2000003" namespace="Benchmarks"/>
</type>
</parameter>
<parameter name="item" position="1"><type spec="Class"><definition assemblyName="mscorlib" name="Object" token="2000002" namespace="System"/>
</type>
</parameter>
</definition>
</method>
<code><![CDATA[Debug.Assert(this.stack != (Stack)null, "this.stack");
]]></code>
</fix>
<fix rank="5" testid="dbff3083-51c1-48f8-ba7e-ec2e2a3419e7" kind="precondition" shortMethodNameWithParameters="FixedSizeStackTest.TestPush(FixedSizeStack, Object)" imports="Microsoft.ExtendedReflection.Collections.SafeSet`1[System.String]"><reference name="Microsoft.Pex.Framework"/>
<reference name="mscorlib"/>
<reference name="Microsoft.ExtendedReflection"/>
<method><definition assemblyName="Benchmarks" name="TestPush" token="6000007"><declaringType assemblyName="Benchmarks" name="FixedSizeStackTest" token="2000004" namespace="Benchmarks"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Benchmarks" name="FixedSizeStackTest" token="2000004" namespace="Benchmarks"/>
</type>
</parameter>
<parameter name="stack" position="1"><type spec="Class"><definition assemblyName="Benchmarks" name="FixedSizeStack" token="2000003" namespace="Benchmarks"/>
</type>
</parameter>
<parameter name="item" position="2"><type spec="Class"><definition assemblyName="mscorlib" name="Object" token="2000002" namespace="System"/>
</type>
</parameter>
</definition>
</method>
<code><![CDATA[PexAssume.IsNotNull((object)(stack.stack), "stack.stack");
]]></code>
</fix>
<pathAssumption><![CDATA[FixedSizeStack s0 = new;
return stack == s0 && stack != (FixedSizeStack)null;
]]></pathAssumption>
<pathCondition><![CDATA[return stack_stack == (Stack)null;
]]></pathCondition>
</generatedTest>
<log level="message" time="2015-11-27 23:30:31Z" category="coverage" message="coverage increased from 0 to 1 blocks (+1) after flipping Benchmarks.FixedSizeStackTest.TestPush at 0x0003"/>
<log level="error" time="2015-11-27 23:30:31Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to open"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:31Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to rollback"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<test name="TestPush" state="success" duration="0.01"/>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStackTest.TestPush at 0x0003"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[return stack == (FixedSizeStack)null;

Feasible prefixes:
FixedSizeStack s0 = new;
return stack == s0;
return stack != (FixedSizeStack)null;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStack.Push at 0x&lt;unknown offset&gt;"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s1 = new;
Stack s0 = stack == s1 ? stack_stack : stack.stack;
return s0 != (Stack)null;

Feasible prefixes:
FixedSizeStack s0 = new;
return stack == s0;
return stack != (FixedSizeStack)null;
return stack_stack.GetType() != typeof(Stack);
FixedSizeStack s2 = new;
Stack s1 = stack == s2 ? stack_stack : stack.stack;
return s1.GetType() != typeof(Stack);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<log level="warning" time="2015-11-27 23:30:31Z" wikiTopic="Missing Wiki Topic" category="fieldmodificationtype" message="Encountered unknown modification type for reference type ldarg.1"/>
<log level="error" time="2015-11-27 23:30:31Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to open"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:31Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to rollback"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<test name="TestPush" state="success" duration="0.01"/>
<log level="error" time="2015-11-27 23:30:31Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to open"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:31Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to rollback"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<test name="TestPush" state="success" duration="0.16"/>
<generatedTest id="9e3c2e56-f8fd-452f-b4e9-c2c292b58dfa" index="3" run="6" status="normaltermination" generated="true" new="true" assemblyName="Benchmarks" name="TestPush327"><declaringType assemblyName="Benchmarks" name="FixedSizeStackTest" token="ffffffff" namespace="Benchmarks"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Benchmarks" name="FixedSizeStackTest" token="ffffffff" namespace="Benchmarks"/>
</type>
</parameter>
<rcov name="Block" dcov="3" dtot="0" acov="4" atot="8"/>
<rcov name="asserts" dcov="0" dtot="0" acov="0" atot="0"/>
<value name="stack">new FixedSizeStack{}</value>
<value name="item">null</value>
<code><![CDATA[Stack stack;
FixedSizeStack fixedSizeStack;
object[] os = new object[0];
stack = StackFactory.Create(os);
fixedSizeStack = new FixedSizeStack(stack);
this.TestPush(fixedSizeStack, (object)null);
]]></code>
<methodCode imports="Microsoft.VisualStudio.TestTools.UnitTesting;Microsoft.Pex.Framework.Generated"><![CDATA[[TestMethod]
[PexGeneratedBy(typeof(FixedSizeStackTest))]
public void TestPush327()
{
    Stack stack;
    FixedSizeStack fixedSizeStack;
    object[] os = new object[0];
    stack = StackFactory.Create(os);
    fixedSizeStack = new FixedSizeStack(stack);
    this.TestPush(fixedSizeStack, (object)null);
}
]]></methodCode>
<reference name="Microsoft.VisualStudio.QualityTools.UnitTestFramework"/>
<reference name="mscorlib" location="C:\Windows\Microsoft.NET\Framework\v4.0.30319\mscorlib.dll"/>
<reference name="Microsoft.Pex.Framework"/>
<reference name="Benchmarks" location="C:\Users\vagrant\Downloads\CovanaReleaseV0.1\Covana\Benchmarks\bin\Debug\Benchmarks.dll"/>
<pathAssumption><![CDATA[Stack s0 = new;
Stack s2 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
Stack s1 = s2;
return (s1 == s0 || stack_stack == s0) && s1 != (Stack)null && stack != (FixedSizeStack)null && stack == (FixedSizeStack)s0;
]]></pathAssumption>
<pathCondition><![CDATA[Stack s2 = new;
List<object> s3 = new;
List<object> s1 = stack_stack == s2 ? s3 : stack_stack.items;
List<object> s0 = s1;
int s4 = s0 == s3 ? 0 : s0._size;
List<object> s5 = s0 == s3 ? s3 : (List<object>)(s0._items);
return objs != (object[])null && objs.Length < 1 && stack_stack != (Stack)null && 
                                                    s0 != (List<object>)null && methodof(s0.get_Count) == methodof(List<object>.get_Count) && methodof(s0.Add) == methodof(List<object>.Add) && s4 == 0 && ((Array)s5).Length == 0;
]]></pathCondition>
</generatedTest>
<log level="message" time="2015-11-27 23:30:31Z" category="coverage" message="coverage increased from 1 to 4 blocks (+3) after flipping Benchmarks.StackFactory.Create at 0x0002"/>
<log level="error" time="2015-11-27 23:30:32Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to open"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:32Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to rollback"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<test name="TestPush" state="success" duration="0.02"/>
<log level="message" time="2015-11-27 23:30:32Z" category="symbols" message="could not load symbols for C:\Windows\Microsoft.NET\Framework\v4.0.30319\mscorlib.dll"/>
<dump category="My Category" title="flipped location: System.Collections.Generic.List`1.Add at 0x000e"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
int s0 = s1 == s6 ? 0 : s1._size;
List<object> s7 = s1 == s6 ? s6 : (List<object>)(s1._items);
return s0 != ((Array)s7).Length;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length < 1;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 0 : s9._size;
return s8 != 10;
Stack s14 = new;
List<object> s15 = new;
List<object> s13 = stack_stack == s14 ? s15 : stack_stack.items;
return methodof(s13.get_Count) == methodof(List<object>.get_Count);
Stack s17 = new;
List<object> s18 = new;
List<object> s16 = stack_stack == s17 ? s18 : stack_stack.items;
return methodof(s16.Add) == methodof(List<object>.Add);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<log level="warning" time="2015-11-27 23:30:32Z" wikiTopic="Missing Wiki Topic" category="fieldmodificationtype" message="Encountered unknown modification type for reference type ldloc.0"/>
<log level="warning" time="2015-11-27 23:30:32Z" wikiTopic="Missing Wiki Topic" category="fieldmodificationtype" message="Encountered unknown modification type for reference type ldsfld"/>
<dump category="My Category" title="flipped location: System.Collections.Generic.List`1.set_Capacity at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
int s0 = s1 == s6 ? 0 : s1._size;
return 4 < s0;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length < 1;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s9 = new;
List<object> s10 = new;
List<object> s8 = stack_stack == s9 ? s10 : stack_stack.items;
return methodof(s8.get_Count) == methodof(List<object>.get_Count);
Stack s12 = new;
List<object> s13 = new;
List<object> s11 = stack_stack == s12 ? s13 : stack_stack.items;
return methodof(s11.Add) == methodof(List<object>.Add);
Stack s17 = new;
List<object> s18 = new;
List<object> s16 = stack_stack == s17 ? s18 : stack_stack.items;
List<object> s15 = s16;
int s14 = s15 == s18 ? 0 : s15._size;
return s14 == 0;
Stack s22 = new;
List<object> s23 = new;
List<object> s21 = stack_stack == s22 ? s23 : stack_stack.items;
List<object> s20 = s21;
List<object> s19 = s20 == s23 ? s23 : (List<object>)(s20._items);
return ((Array)s19).Length == 0;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStack.Push at 0x0015"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
int s0 = s1 == s6 ? 0 : s1._size;
return s0 == 10;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length < 1;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s9 = new;
List<object> s10 = new;
List<object> s8 = stack_stack == s9 ? s10 : stack_stack.items;
return methodof(s8.get_Count) == methodof(List<object>.get_Count);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: System.Collections.Generic.List`1.set_Capacity at 0x002f"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
int s0 = s1 == s6 ? 0 : s1._size;
return 0 < s0;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length < 1;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s9 = new;
List<object> s10 = new;
List<object> s8 = stack_stack == s9 ? s10 : stack_stack.items;
return methodof(s8.get_Count) == methodof(List<object>.get_Count);
Stack s12 = new;
List<object> s13 = new;
List<object> s11 = stack_stack == s12 ? s13 : stack_stack.items;
return methodof(s11.Add) == methodof(List<object>.Add);
Stack s17 = new;
List<object> s18 = new;
List<object> s16 = stack_stack == s17 ? s18 : stack_stack.items;
List<object> s15 = s16;
int s14 = s15 == s18 ? 0 : s15._size;
return s14 == 0;
Stack s22 = new;
List<object> s23 = new;
List<object> s21 = stack_stack == s22 ? s23 : stack_stack.items;
List<object> s20 = s21;
List<object> s19 = s20 == s23 ? s23 : (List<object>)(s20._items);
return ((Array)s19).Length == 0;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStack.Push at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s1 = new;
Stack s0 = stack == s1 ? stack_stack : stack.stack;
return s0 == (Stack)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length < 1;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.get_Count at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return s0 == (List<object>)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length < 1;
return stack_stack != (Stack)null;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.Push at 0x0008"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return methodof(s0.Add) != methodof(List<object>.Add);

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length < 1;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 0 : s9._size;
return s8 != 10;
Stack s14 = new;
List<object> s15 = new;
List<object> s13 = stack_stack == s14 ? s15 : stack_stack.items;
return methodof(s13.get_Count) == methodof(List<object>.get_Count);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: System.Collections.Generic.List`1.EnsureCapacity at 0x0009"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
List<object> s0 = s1 == s6 ? s6 : (List<object>)(s1._items);
int s7 = s1 == s6 ? 0 : s1._size;
return ((Array)s0).Length >= 1 + s7;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length < 1;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 0 : s9._size;
return s8 != 10;
Stack s16 = new;
List<object> s17 = new;
List<object> s15 = stack_stack == s16 ? s17 : stack_stack.items;
List<object> s14 = s15;
int s13 = s14 == s17 ? 0 : s14._size;
List<object> s18 = s14 == s17 ? s17 : (List<object>)(s14._items);
return s13 == ((Array)s18).Length;
Stack s20 = new;
List<object> s21 = new;
List<object> s19 = stack_stack == s20 ? s21 : stack_stack.items;
return methodof(s19.get_Count) == methodof(List<object>.get_Count);
Stack s23 = new;
List<object> s24 = new;
List<object> s22 = stack_stack == s23 ? s24 : stack_stack.items;
return methodof(s22.Add) == methodof(List<object>.Add);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<log level="warning" time="2015-11-27 23:30:32Z" wikiTopic="Missing Wiki Topic" category="fieldmodificationtype" message="Encountered unknown modification type for reference type ldarg.2"/>
<log level="warning" time="2015-11-27 23:30:32Z" wikiTopic="Missing Wiki Topic" category="fieldmodificationtype" message="Encountered unknown modification type for integer type ldloc.1"/>
<log level="warning" time="2015-11-27 23:30:32Z" wikiTopic="Missing Wiki Topic" category="fieldmodificationtype" message="Encountered unknown modification type for integer type ldc.i4.0"/>
<dump category="My Category" title="flipped location: System.Collections.Generic.List`1.EnsureCapacity at 0x0013"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
List<object> s0 = s1 == s6 ? s6 : (List<object>)(s1._items);
return ((Array)s0).Length != 0;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length < 1;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 0 : s9._size;
return s8 != 10;
Stack s16 = new;
List<object> s17 = new;
List<object> s15 = stack_stack == s16 ? s17 : stack_stack.items;
List<object> s14 = s15;
int s13 = s14 == s17 ? 0 : s14._size;
List<object> s18 = s14 == s17 ? s17 : (List<object>)(s14._items);
return s13 == ((Array)s18).Length;
Stack s22 = new;
List<object> s23 = new;
List<object> s21 = stack_stack == s22 ? s23 : stack_stack.items;
List<object> s20 = s21;
List<object> s19 = s20 == s23 ? s23 : (List<object>)(s20._items);
int s24 = s20 == s23 ? 0 : s20._size;
return ((Array)s19).Length < 1 + s24;
Stack s26 = new;
List<object> s27 = new;
List<object> s25 = stack_stack == s26 ? s27 : stack_stack.items;
return methodof(s25.get_Count) == methodof(List<object>.get_Count);
Stack s29 = new;
List<object> s30 = new;
List<object> s28 = stack_stack == s29 ? s30 : stack_stack.items;
return methodof(s28.Add) == methodof(List<object>.Add);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: System.Collections.Generic.List`1.EnsureCapacity at 0x0033"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
int s0 = s1 == s6 ? 0 : s1._size;
return 4 < 1 + s0;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length < 1;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s9 = new;
List<object> s10 = new;
List<object> s8 = stack_stack == s9 ? s10 : stack_stack.items;
return methodof(s8.get_Count) == methodof(List<object>.get_Count);
Stack s12 = new;
List<object> s13 = new;
List<object> s11 = stack_stack == s12 ? s13 : stack_stack.items;
return methodof(s11.Add) == methodof(List<object>.Add);
Stack s17 = new;
List<object> s18 = new;
List<object> s16 = stack_stack == s17 ? s18 : stack_stack.items;
List<object> s15 = s16;
int s14 = s15 == s18 ? 0 : s15._size;
return s14 == 0;
Stack s22 = new;
List<object> s23 = new;
List<object> s21 = stack_stack == s22 ? s23 : stack_stack.items;
List<object> s20 = s21;
List<object> s19 = s20 == s23 ? s23 : (List<object>)(s20._items);
return ((Array)s19).Length == 0;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<log level="message" time="2015-11-27 23:30:32Z" category="symbols" message="could not load symbols for C:\Windows\assembly\GAC_MSIL\Microsoft.Pex.Framework\0.94.0.0__31bf3856ad364e35\Microsoft.Pex.Framework.dll"/>
<log level="error" time="2015-11-27 23:30:32Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to open"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:32Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to rollback"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<test name="TestPush" state="success" duration="0.01"/>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStackTest.TestPush at 0x0003"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[return stack == (FixedSizeStack)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length == 1;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.get_Count at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return methodof(s0.get_Count) != methodof(List<object>.get_Count);

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
return objs.Length == 1;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStackTest.TestPush at 0x0003"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[return stack == (FixedSizeStack)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length < 1;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<log level="error" time="2015-11-27 23:30:32Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to open"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:32Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to rollback"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<test name="TestPush" state="success" duration="0.01"/>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStackTest.TestPush at 0x0003"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[return stack == (FixedSizeStack)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length == 2;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<log level="error" time="2015-11-27 23:30:32Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to open"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:32Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to rollback"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<test name="TestPush" state="success" duration="0.00"/>
<log level="error" time="2015-11-27 23:30:32Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to open"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:32Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to rollback"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<test name="TestPush" state="success" duration="0.01"/>
<dump category="My Category" title="flipped location: System.Collections.Generic.List`1.EnsureCapacity at 0x0029"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
object[] s7 = new;
object[] s0 = s1 == s6 ? s7 : s1._items;
return 2146435071u < (uint)(2 * s0.Length);

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 4 : s9._size;
return s8 != 10;
Stack s16 = new;
List<object> s17 = new;
List<object> s15 = stack_stack == s16 ? s17 : stack_stack.items;
List<object> s14 = s15;
int s13 = s14 == s17 ? 4 : s14._size;
object[] s19 = new;
object[] s18 = s14 == s17 ? s19 : s14._items;
return s13 == s18.Length;
Stack s23 = new;
List<object> s24 = new;
List<object> s22 = stack_stack == s23 ? s24 : stack_stack.items;
List<object> s21 = s22;
object[] s25 = new;
object[] s20 = s21 == s24 ? s25 : s21._items;
int s26 = s21 == s24 ? 4 : s21._size;
return s20.Length < 1 + s26;
Stack s30 = new;
List<object> s31 = new;
List<object> s29 = stack_stack == s30 ? s31 : stack_stack.items;
List<object> s28 = s29;
object[] s32 = new;
object[] s27 = s28 == s31 ? s32 : s28._items;
return s27.Length != 0;
return objs.Length == 4;
Stack s34 = new;
List<object> s35 = new;
List<object> s33 = stack_stack == s34 ? s35 : stack_stack.items;
return methodof(s33.get_Count) == methodof(List<object>.get_Count);
Stack s37 = new;
List<object> s38 = new;
List<object> s36 = stack_stack == s37 ? s38 : stack_stack.items;
return methodof(s36.Add) == methodof(List<object>.Add);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: System.Collections.Generic.List`1.set_Capacity at 0x001f"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
object[] s7 = new;
object[] s0 = s1 == s6 ? s7 : s1._items;
return 2 * s0.Length < 1;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 4 : s9._size;
return s8 != 10;
Stack s16 = new;
List<object> s17 = new;
List<object> s15 = stack_stack == s16 ? s17 : stack_stack.items;
List<object> s14 = s15;
int s13 = s14 == s17 ? 4 : s14._size;
object[] s19 = new;
object[] s18 = s14 == s17 ? s19 : s14._items;
return s13 == s18.Length;
Stack s23 = new;
List<object> s24 = new;
List<object> s22 = stack_stack == s23 ? s24 : stack_stack.items;
List<object> s21 = s22;
object[] s25 = new;
object[] s20 = s21 == s24 ? s25 : s21._items;
int s26 = s21 == s24 ? 4 : s21._size;
return s20.Length < 1 + s26;
Stack s30 = new;
List<object> s31 = new;
List<object> s29 = stack_stack == s30 ? s31 : stack_stack.items;
List<object> s28 = s29;
object[] s32 = new;
object[] s27 = s28 == s31 ? s32 : s28._items;
return s27.Length != 0;
Stack s36 = new;
List<object> s37 = new;
List<object> s35 = stack_stack == s36 ? s37 : stack_stack.items;
List<object> s34 = s35;
object[] s38 = new;
object[] s33 = s34 == s37 ? s38 : s34._items;
return (uint)(2 * s33.Length) < 2146435072u;
return objs.Length == 4;
Stack s40 = new;
List<object> s41 = new;
List<object> s39 = stack_stack == s40 ? s41 : stack_stack.items;
return methodof(s39.get_Count) == methodof(List<object>.get_Count);
Stack s43 = new;
List<object> s44 = new;
List<object> s42 = stack_stack == s43 ? s44 : stack_stack.items;
return methodof(s42.Add) == methodof(List<object>.Add);
Stack s48 = new;
List<object> s49 = new;
List<object> s47 = stack_stack == s48 ? s49 : stack_stack.items;
List<object> s46 = s47;
object[] s50 = new;
object[] s45 = s46 == s49 ? s50 : s46._items;
int s51 = s46 == s49 ? 4 : s46._size;
return 2 * s45.Length >= 1 + s51;
Stack s55 = new;
List<object> s56 = new;
List<object> s54 = stack_stack == s55 ? s56 : stack_stack.items;
List<object> s53 = s54;
object[] s57 = new;
object[] s52 = s53 == s56 ? s57 : s53._items;
int s58 = s53 == s56 ? 4 : s53._size;
return 2 * s52.Length >= s58;
Stack s63 = new;
List<object> s64 = new;
List<object> s62 = stack_stack == s63 ? s64 : stack_stack.items;
List<object> s61 = s62;
object[] s65 = new;
object[] s60 = s61 == s64 ? s65 : s61._items;
int s59 = s60.Length;
return 2 * s59 != s59;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: System.Collections.Generic.List`1.set_Capacity at 0x001b"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s6 = new;
Stack s5 = stack == s6 ? stack_stack : stack.stack;
Stack s4 = s5;
List<object> s7 = new;
List<object> s3 = s4 == (Stack)s6 ? s7 : s4.items;
List<object> s2 = s3;
object[] s8 = new;
object[] s1 = s2 == s7 ? s8 : s2._items;
int s0 = s1.Length;
return 2 * s0 == s0;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 4 : s9._size;
return s8 != 10;
Stack s16 = new;
List<object> s17 = new;
List<object> s15 = stack_stack == s16 ? s17 : stack_stack.items;
List<object> s14 = s15;
int s13 = s14 == s17 ? 4 : s14._size;
object[] s19 = new;
object[] s18 = s14 == s17 ? s19 : s14._items;
return s13 == s18.Length;
Stack s23 = new;
List<object> s24 = new;
List<object> s22 = stack_stack == s23 ? s24 : stack_stack.items;
List<object> s21 = s22;
object[] s25 = new;
object[] s20 = s21 == s24 ? s25 : s21._items;
int s26 = s21 == s24 ? 4 : s21._size;
return s20.Length < 1 + s26;
Stack s30 = new;
List<object> s31 = new;
List<object> s29 = stack_stack == s30 ? s31 : stack_stack.items;
List<object> s28 = s29;
object[] s32 = new;
object[] s27 = s28 == s31 ? s32 : s28._items;
return s27.Length != 0;
Stack s36 = new;
List<object> s37 = new;
List<object> s35 = stack_stack == s36 ? s37 : stack_stack.items;
List<object> s34 = s35;
object[] s38 = new;
object[] s33 = s34 == s37 ? s38 : s34._items;
return (uint)(2 * s33.Length) < 2146435072u;
return objs.Length == 4;
Stack s40 = new;
List<object> s41 = new;
List<object> s39 = stack_stack == s40 ? s41 : stack_stack.items;
return methodof(s39.get_Count) == methodof(List<object>.get_Count);
Stack s43 = new;
List<object> s44 = new;
List<object> s42 = stack_stack == s43 ? s44 : stack_stack.items;
return methodof(s42.Add) == methodof(List<object>.Add);
Stack s48 = new;
List<object> s49 = new;
List<object> s47 = stack_stack == s48 ? s49 : stack_stack.items;
List<object> s46 = s47;
object[] s50 = new;
object[] s45 = s46 == s49 ? s50 : s46._items;
int s51 = s46 == s49 ? 4 : s46._size;
return 2 * s45.Length >= 1 + s51;
Stack s55 = new;
List<object> s56 = new;
List<object> s54 = stack_stack == s55 ? s56 : stack_stack.items;
List<object> s53 = s54;
object[] s57 = new;
object[] s52 = s53 == s56 ? s57 : s53._items;
int s58 = s53 == s56 ? 4 : s53._size;
return 2 * s52.Length >= s58;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<log level="error" time="2015-11-27 23:30:32Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to open"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:32Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to rollback"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<test name="TestPush" state="success" duration="0.02"/>
<generatedTest id="8a734fd5-f41a-4e70-b7cf-fdbab1066199" index="4" run="12" status="normaltermination" generated="true" new="true" assemblyName="Benchmarks" name="TestPush32701"><declaringType assemblyName="Benchmarks" name="FixedSizeStackTest" token="ffffffff" namespace="Benchmarks"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Benchmarks" name="FixedSizeStackTest" token="ffffffff" namespace="Benchmarks"/>
</type>
</parameter>
<rcov name="Block" dcov="0" dtot="0" acov="4" atot="8"/>
<rcov name="asserts" dcov="0" dtot="0" acov="0" atot="0"/>
<value name="stack">new FixedSizeStack{}</value>
<value name="item">null</value>
<code><![CDATA[Stack stack;
FixedSizeStack fixedSizeStack;
object[] os = new object[4];
stack = StackFactory.Create(os);
fixedSizeStack = new FixedSizeStack(stack);
this.TestPush(fixedSizeStack, (object)null);
]]></code>
<methodCode imports="Microsoft.VisualStudio.TestTools.UnitTesting;Microsoft.Pex.Framework.Generated"><![CDATA[[TestMethod]
[PexGeneratedBy(typeof(FixedSizeStackTest))]
public void TestPush32701()
{
    Stack stack;
    FixedSizeStack fixedSizeStack;
    object[] os = new object[4];
    stack = StackFactory.Create(os);
    fixedSizeStack = new FixedSizeStack(stack);
    this.TestPush(fixedSizeStack, (object)null);
}
]]></methodCode>
<reference name="Microsoft.VisualStudio.QualityTools.UnitTestFramework"/>
<reference name="mscorlib" location="C:\Windows\Microsoft.NET\Framework\v4.0.30319\mscorlib.dll"/>
<reference name="Microsoft.Pex.Framework"/>
<reference name="Benchmarks" location="C:\Users\vagrant\Downloads\CovanaReleaseV0.1\Covana\Benchmarks\bin\Debug\Benchmarks.dll"/>
<pathAssumption><![CDATA[Stack s0 = new;
Stack s2 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
Stack s1 = s2;
return (s1 == s0 || stack_stack == s0) && s1 != (Stack)null && stack != (FixedSizeStack)null && stack == (FixedSizeStack)s0;
]]></pathAssumption>
<pathCondition><![CDATA[Stack s2 = new;
List<object> s3 = new;
List<object> s1 = stack_stack == s2 ? s3 : stack_stack.items;
List<object> s0 = s1;
int s5 = s0 == s3 ? 4 : s0._size;
int s4 = s5;
object[] s9 = new;
object[] s8 = s0 == s3 ? s9 : s0._items;
object[] s7 = s8;
int s6 = s7.Length;
return objs != (object[])null && 
       stack_stack != (Stack)null && s0 != (List<object>)null && s4 != 10 && s4 == s6 && s6 < 1 + s4 && s6 != 0 && (uint)(2 * s6) < 2146435072u && 0 < 2 * s6 && 0 < s4 && s7 != (object[])null && 
                                                                                                                                                                           objs.Length == 4 && methodof(s0.get_Count) == methodof(List<object>.get_Count) && methodof(s0.Add) == methodof(List<object>.Add) && 2 * s6 >= 1 + s4 && 2 * s6 >= s4 && 2 * s6 != s6 && s6 >= s4;
]]></pathCondition>
</generatedTest>
<log level="message" time="2015-11-27 23:30:32Z" category="symbols" message="could not load symbols for C:\Windows\assembly\GAC_MSIL\Microsoft.ExtendedReflection\0.94.0.0__31bf3856ad364e35\Microsoft.ExtendedReflection.dll"/>
<dump category="My Category" title="flipped location: __InstrumentedSummarizers.System.Array.Copy at 0x0041"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
object[] s7 = new;
object[] s0 = s1 == s6 ? s7 : s1._items;
int s8 = s1 == s6 ? 4 : s1._size;
return s0.Length < s8;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 4 : s9._size;
return s8 != 10;
Stack s16 = new;
List<object> s17 = new;
List<object> s15 = stack_stack == s16 ? s17 : stack_stack.items;
List<object> s14 = s15;
int s13 = s14 == s17 ? 4 : s14._size;
object[] s19 = new;
object[] s18 = s14 == s17 ? s19 : s14._items;
return s13 == s18.Length;
Stack s23 = new;
List<object> s24 = new;
List<object> s22 = stack_stack == s23 ? s24 : stack_stack.items;
List<object> s21 = s22;
object[] s25 = new;
object[] s20 = s21 == s24 ? s25 : s21._items;
int s26 = s21 == s24 ? 4 : s21._size;
return s20.Length < 1 + s26;
Stack s30 = new;
List<object> s31 = new;
List<object> s29 = stack_stack == s30 ? s31 : stack_stack.items;
List<object> s28 = s29;
object[] s32 = new;
object[] s27 = s28 == s31 ? s32 : s28._items;
return s27.Length != 0;
Stack s36 = new;
List<object> s37 = new;
List<object> s35 = stack_stack == s36 ? s37 : stack_stack.items;
List<object> s34 = s35;
object[] s38 = new;
object[] s33 = s34 == s37 ? s38 : s34._items;
return (uint)(2 * s33.Length) < 2146435072u;
Stack s42 = new;
List<object> s43 = new;
List<object> s41 = stack_stack == s42 ? s43 : stack_stack.items;
List<object> s40 = s41;
object[] s44 = new;
object[] s39 = s40 == s43 ? s44 : s40._items;
return 0 < 2 * s39.Length;
Stack s48 = new;
List<object> s49 = new;
List<object> s47 = stack_stack == s48 ? s49 : stack_stack.items;
List<object> s46 = s47;
int s45 = s46 == s49 ? 4 : s46._size;
return 0 < s45;
Stack s53 = new;
List<object> s54 = new;
List<object> s52 = stack_stack == s53 ? s54 : stack_stack.items;
List<object> s51 = s52;
object[] s55 = new;
object[] s50 = s51 == s54 ? s55 : s51._items;
return s50 != (object[])null;
return objs.Length == 4;
Stack s57 = new;
List<object> s58 = new;
List<object> s56 = stack_stack == s57 ? s58 : stack_stack.items;
return methodof(s56.get_Count) == methodof(List<object>.get_Count);
Stack s60 = new;
List<object> s61 = new;
List<object> s59 = stack_stack == s60 ? s61 : stack_stack.items;
return methodof(s59.Add) == methodof(List<object>.Add);
Stack s65 = new;
List<object> s66 = new;
List<object> s64 = stack_stack == s65 ? s66 : stack_stack.items;
List<object> s63 = s64;
object[] s67 = new;
object[] s62 = s63 == s66 ? s67 : s63._items;
int s68 = s63 == s66 ? 4 : s63._size;
return 2 * s62.Length >= 1 + s68;
Stack s72 = new;
List<object> s73 = new;
List<object> s71 = stack_stack == s72 ? s73 : stack_stack.items;
List<object> s70 = s71;
object[] s74 = new;
object[] s69 = s70 == s73 ? s74 : s70._items;
int s75 = s70 == s73 ? 4 : s70._size;
return 2 * s69.Length >= s75;
Stack s80 = new;
List<object> s81 = new;
List<object> s79 = stack_stack == s80 ? s81 : stack_stack.items;
List<object> s78 = s79;
object[] s82 = new;
object[] s77 = s78 == s81 ? s82 : s78._items;
int s76 = s77.Length;
return 2 * s76 != s76;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: __InstrumentedSummarizers.System.Array.Copy at 0x0009"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
object[] s7 = new;
object[] s0 = s1 == s6 ? s7 : s1._items;
return s0 == (object[])null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 4 : s9._size;
return s8 != 10;
Stack s16 = new;
List<object> s17 = new;
List<object> s15 = stack_stack == s16 ? s17 : stack_stack.items;
List<object> s14 = s15;
int s13 = s14 == s17 ? 4 : s14._size;
object[] s19 = new;
object[] s18 = s14 == s17 ? s19 : s14._items;
return s13 == s18.Length;
Stack s23 = new;
List<object> s24 = new;
List<object> s22 = stack_stack == s23 ? s24 : stack_stack.items;
List<object> s21 = s22;
object[] s25 = new;
object[] s20 = s21 == s24 ? s25 : s21._items;
int s26 = s21 == s24 ? 4 : s21._size;
return s20.Length < 1 + s26;
Stack s30 = new;
List<object> s31 = new;
List<object> s29 = stack_stack == s30 ? s31 : stack_stack.items;
List<object> s28 = s29;
object[] s32 = new;
object[] s27 = s28 == s31 ? s32 : s28._items;
return s27.Length != 0;
Stack s36 = new;
List<object> s37 = new;
List<object> s35 = stack_stack == s36 ? s37 : stack_stack.items;
List<object> s34 = s35;
object[] s38 = new;
object[] s33 = s34 == s37 ? s38 : s34._items;
return (uint)(2 * s33.Length) < 2146435072u;
Stack s42 = new;
List<object> s43 = new;
List<object> s41 = stack_stack == s42 ? s43 : stack_stack.items;
List<object> s40 = s41;
object[] s44 = new;
object[] s39 = s40 == s43 ? s44 : s40._items;
return 0 < 2 * s39.Length;
Stack s48 = new;
List<object> s49 = new;
List<object> s47 = stack_stack == s48 ? s49 : stack_stack.items;
List<object> s46 = s47;
int s45 = s46 == s49 ? 4 : s46._size;
return 0 < s45;
return objs.Length == 4;
Stack s51 = new;
List<object> s52 = new;
List<object> s50 = stack_stack == s51 ? s52 : stack_stack.items;
return methodof(s50.get_Count) == methodof(List<object>.get_Count);
Stack s54 = new;
List<object> s55 = new;
List<object> s53 = stack_stack == s54 ? s55 : stack_stack.items;
return methodof(s53.Add) == methodof(List<object>.Add);
Stack s59 = new;
List<object> s60 = new;
List<object> s58 = stack_stack == s59 ? s60 : stack_stack.items;
List<object> s57 = s58;
object[] s61 = new;
object[] s56 = s57 == s60 ? s61 : s57._items;
int s62 = s57 == s60 ? 4 : s57._size;
return 2 * s56.Length >= 1 + s62;
Stack s66 = new;
List<object> s67 = new;
List<object> s65 = stack_stack == s66 ? s67 : stack_stack.items;
List<object> s64 = s65;
object[] s68 = new;
object[] s63 = s64 == s67 ? s68 : s64._items;
int s69 = s64 == s67 ? 4 : s64._size;
return 2 * s63.Length >= s69;
Stack s74 = new;
List<object> s75 = new;
List<object> s73 = stack_stack == s74 ? s75 : stack_stack.items;
List<object> s72 = s73;
object[] s76 = new;
object[] s71 = s72 == s75 ? s76 : s72._items;
int s70 = s71.Length;
return 2 * s70 != s70;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<log level="error" time="2015-11-27 23:30:33Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to open"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:33Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to rollback"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<test name="TestPush" state="success" duration="0.00"/>
<log level="error" time="2015-11-27 23:30:33Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to open"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:33Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to rollback"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<test name="TestPush" state="success" duration="0.00"/>
<log level="error" time="2015-11-27 23:30:33Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to open"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:33Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to rollback"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<test name="TestPush" state="success" duration="0.00"/>
<log level="error" time="2015-11-27 23:30:33Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to open"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:33Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to rollback"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<test name="TestPush" state="success" duration="0.00"/>
<log level="error" time="2015-11-27 23:30:33Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to open"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:33Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to rollback"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<test name="TestPush" state="success" duration="0.00"/>
<log level="error" time="2015-11-27 23:30:33Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to open"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:33Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to rollback"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<test name="TestPush" state="success" duration="0.00"/>
<log level="error" time="2015-11-27 23:30:33Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to open"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:33Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to rollback"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<test name="TestPush" state="success" duration="0.00"/>
<log level="error" time="2015-11-27 23:30:33Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to open"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:33Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to rollback"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<test name="TestPush" state="success" duration="0.01"/>
<log level="error" time="2015-11-27 23:30:33Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to open"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:33Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to rollback"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:33Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to open"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:33Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to rollback"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:33Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to open"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:33Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to rollback"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<generatedTest id="cac0835f-7ccc-453c-aa54-8378647426e0" index="5" run="20" exceptionState="unexpected" status="exception" failed="true" generated="true" new="true" assemblyName="Benchmarks" name="TestPushThrowsException971"><declaringType assemblyName="Benchmarks" name="FixedSizeStackTest" token="ffffffff" namespace="Benchmarks"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Benchmarks" name="FixedSizeStackTest" token="ffffffff" namespace="Benchmarks"/>
</type>
</parameter>
<rcov name="Block" dcov="2" dtot="0" acov="6" atot="8"/>
<rcov name="asserts" dcov="0" dtot="0" acov="0" atot="0"/>
<value name="stack">new FixedSizeStack{}</value>
<value name="item">null</value>
<code><![CDATA[Stack stack;
FixedSizeStack fixedSizeStack;
object[] os = new object[10];
stack = StackFactory.Create(os);
fixedSizeStack = new FixedSizeStack(stack);
this.TestPush(fixedSizeStack, (object)null);
]]></code>
<methodCode imports="Microsoft.VisualStudio.TestTools.UnitTesting;Microsoft.Pex.Framework.Generated;System"><![CDATA[[TestMethod]
[PexGeneratedBy(typeof(FixedSizeStackTest))]
[PexRaisedException(typeof(Exception))]
public void TestPushThrowsException971()
{
    Stack stack;
    FixedSizeStack fixedSizeStack;
    object[] os = new object[10];
    stack = StackFactory.Create(os);
    fixedSizeStack = new FixedSizeStack(stack);
    this.TestPush(fixedSizeStack, (object)null);
}
]]></methodCode>
<reference name="Microsoft.VisualStudio.QualityTools.UnitTestFramework"/>
<reference name="mscorlib" location="C:\Windows\Microsoft.NET\Framework\v4.0.30319\mscorlib.dll"/>
<reference name="Microsoft.Pex.Framework"/>
<reference name="Benchmarks" location="C:\Users\vagrant\Downloads\CovanaReleaseV0.1\Covana\Benchmarks\bin\Debug\Benchmarks.dll"/>
<exceptionChain><exception typeDisplayName="Exception" source="Benchmarks"><message><![CDATA[full]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="Exception" token="2000005" namespace="System"/>
</type>
<stackTrace><frame value="  at FixedSizeStack.Push(Object) in C:\Users\vagrant\Downloads\CovanaReleaseV0.1\Covana\Benchmarks\FixedSizeStackTest.cs(53)" method="FixedSizeStack.Push(Object)" offset="34" file="C:\Users\vagrant\Downloads\CovanaReleaseV0.1\Covana\Benchmarks\FixedSizeStackTest.cs" line="53"><method assemblyName="Benchmarks" name="Push" token="6000006"><declaringType assemblyName="Benchmarks" name="FixedSizeStack" token="2000003" namespace="Benchmarks"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Benchmarks" name="FixedSizeStack" token="2000003" namespace="Benchmarks"/>
</type>
</parameter>
<parameter name="item" position="1"><type spec="Class"><definition assemblyName="mscorlib" name="Object" token="2000002" namespace="System"/>
</type>
</parameter>
</method>
<beforeSource><![CDATA[        {
            if (stack.Count == 10)
            {]]></beforeSource>
<source><![CDATA[                throw new Exception("full");]]></source>
<afterSource><![CDATA[            }

            stack.Push(item);]]></afterSource>
</frame>
<frame value="  at FixedSizeStackTest.TestPush(FixedSizeStack, Object) in C:\Users\vagrant\Downloads\CovanaReleaseV0.1\Covana\Benchmarks\FixedSizeStackTest.cs(66)" method="FixedSizeStackTest.TestPush(FixedSizeStack, Object)" offset="1" file="C:\Users\vagrant\Downloads\CovanaReleaseV0.1\Covana\Benchmarks\FixedSizeStackTest.cs" line="66"><method assemblyName="Benchmarks" name="TestPush" token="6000007"><declaringType assemblyName="Benchmarks" name="FixedSizeStackTest" token="2000004" namespace="Benchmarks"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Benchmarks" name="FixedSizeStackTest" token="2000004" namespace="Benchmarks"/>
</type>
</parameter>
<parameter name="stack" position="1"><type spec="Class"><definition assemblyName="Benchmarks" name="FixedSizeStack" token="2000003" namespace="Benchmarks"/>
</type>
</parameter>
<parameter name="item" position="2"><type spec="Class"><definition assemblyName="mscorlib" name="Object" token="2000002" namespace="System"/>
</type>
</parameter>
</method>
<beforeSource><![CDATA[        [PexMethod]
        public void TestPush(FixedSizeStack stack, object item)
        {]]></beforeSource>
<source><![CDATA[            stack.Push(item);]]></source>
<afterSource><![CDATA[        }
    }
}]]></afterSource>
</frame>
</stackTrace>
</exception>
</exceptionChain>
<fix rank="5" testid="cac0835f-7ccc-453c-aa54-8378647426e0" kind="precondition" shortMethodNameWithParameters="FixedSizeStackTest.TestPush(FixedSizeStack, Object)" imports="Microsoft.ExtendedReflection.Collections.SafeSet`1[System.String]"><reference name="Microsoft.Pex.Framework"/>
<reference name="mscorlib"/>
<reference name="Microsoft.ExtendedReflection"/>
<method><definition assemblyName="Benchmarks" name="TestPush" token="6000007"><declaringType assemblyName="Benchmarks" name="FixedSizeStackTest" token="2000004" namespace="Benchmarks"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Benchmarks" name="FixedSizeStackTest" token="2000004" namespace="Benchmarks"/>
</type>
</parameter>
<parameter name="stack" position="1"><type spec="Class"><definition assemblyName="Benchmarks" name="FixedSizeStack" token="2000003" namespace="Benchmarks"/>
</type>
</parameter>
<parameter name="item" position="2"><type spec="Class"><definition assemblyName="mscorlib" name="Object" token="2000002" namespace="System"/>
</type>
</parameter>
</definition>
</method>
<code><![CDATA[PexAssume.IsTrue(stack.stack.Count != 10, "stack.stack.Count == 10");
]]></code>
</fix>
<pathAssumption><![CDATA[Stack s0 = new;
Stack s2 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
Stack s1 = s2;
return (s1 == s0 || stack_stack == s0) && s1 != (Stack)null && stack != (FixedSizeStack)null && stack == (FixedSizeStack)s0;
]]></pathAssumption>
<pathCondition><![CDATA[Stack s2 = new;
List<object> s3 = new;
List<object> s1 = stack_stack == s2 ? s3 : stack_stack.items;
List<object> s0 = s1;
int s4 = s0 == s3 ? 10 : s0._size;
return objs != (object[])null && stack_stack != (Stack)null && s0 != (List<object>)null && objs.Length == 10 && methodof(s0.get_Count) == methodof(List<object>.get_Count) && s4 == 10;
]]></pathCondition>
</generatedTest>
<log level="message" time="2015-11-27 23:30:33Z" category="coverage" message="coverage increased from 4 to 6 blocks (+2) after flipping Benchmarks.StackFactory.Create at 0x0030"/>
<log level="error" time="2015-11-27 23:30:33Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to open"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:33Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to rollback"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<test name="TestPush" state="success" duration="0.01"/>
<log level="error" time="2015-11-27 23:30:33Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to open"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:33Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to rollback"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<test name="TestPush" state="success" duration="0.01"/>
<log level="error" time="2015-11-27 23:30:33Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to open"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:33Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to rollback"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<test name="TestPush" state="success" duration="0.01"/>
<log level="error" time="2015-11-27 23:30:33Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to open"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<log level="error" time="2015-11-27 23:30:33Z" wikiTopic="Missing Wiki Topic" category="execution" message="runtime context Microsoft.Pex.Engine.Libraries.MicrosoftVisualBasicLibrary+ProjectErrorRuntimeContextAttribute+Context failed to rollback"><exceptionChain><exception typeDisplayName="InvalidProgramException" source="Microsoft.VisualBasic"><message><![CDATA[Common Language Runtime detected an invalid program.]]></message>
<type spec="Class"><definition assemblyName="mscorlib" name="InvalidProgramException" token="20000fc" namespace="System"/>
</type>
<stackTrace><frame value="  at ProjectData..ctor()" method="ProjectData..ctor()" offset="-1"><method assemblyName="Microsoft.VisualBasic" name=".ctor" token="600053a"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<parameter this="true" name="this" position="0"><type spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</type>
</parameter>
</method>
</frame>
<frame value="  at ProjectData.GetProjectData()" method="ProjectData.GetProjectData()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="GetProjectData" static="true" token="600053c"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</resultType>
</method>
</frame>
<frame value="  at Information.Err()" method="Information.Err()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="Err" static="true" token="60005ee"><declaringType assemblyName="Microsoft.VisualBasic" name="Information" token="2000087" namespace="Microsoft.VisualBasic"/>
<resultType spec="Class"><definition assemblyName="Microsoft.VisualBasic" name="ErrObject" token="200002f" namespace="Microsoft.VisualBasic"/>
</resultType>
</method>
</frame>
<frame value="  at ProjectData.ClearProjectError()" method="ProjectData.ClearProjectError()" offset="0"><method assemblyName="Microsoft.VisualBasic" name="ClearProjectError" static="true" token="6000538"><declaringType assemblyName="Microsoft.VisualBasic" name="ProjectData" token="200007b" namespace="Microsoft.VisualBasic.CompilerServices"/>
</method>
</frame>
</stackTrace>
</exception>
</exceptionChain>
</log>
<test name="TestPush" state="success" duration="0.00"/>
<dump category="My Category" title="flipped location: Benchmarks.Stack.Push at 0x0008"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return methodof(s0.Add) != methodof(List<object>.Add);

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 8 : s9._size;
return s8 != 10;
return objs.Length == 8;
Stack s14 = new;
List<object> s15 = new;
List<object> s13 = stack_stack == s14 ? s15 : stack_stack.items;
return methodof(s13.get_Count) == methodof(List<object>.get_Count);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: System.Collections.Generic.List`1.set_Capacity at 0x001f"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
object[] s7 = new;
object[] s0 = s1 == s6 ? s7 : s1._items;
return 2 * s0.Length < 1;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 8 : s9._size;
return s8 != 10;
Stack s16 = new;
List<object> s17 = new;
List<object> s15 = stack_stack == s16 ? s17 : stack_stack.items;
List<object> s14 = s15;
int s13 = s14 == s17 ? 8 : s14._size;
object[] s19 = new;
object[] s18 = s14 == s17 ? s19 : s14._items;
return s13 == s18.Length;
Stack s23 = new;
List<object> s24 = new;
List<object> s22 = stack_stack == s23 ? s24 : stack_stack.items;
List<object> s21 = s22;
object[] s25 = new;
object[] s20 = s21 == s24 ? s25 : s21._items;
int s26 = s21 == s24 ? 8 : s21._size;
return s20.Length < 1 + s26;
Stack s30 = new;
List<object> s31 = new;
List<object> s29 = stack_stack == s30 ? s31 : stack_stack.items;
List<object> s28 = s29;
object[] s32 = new;
object[] s27 = s28 == s31 ? s32 : s28._items;
return s27.Length != 0;
Stack s36 = new;
List<object> s37 = new;
List<object> s35 = stack_stack == s36 ? s37 : stack_stack.items;
List<object> s34 = s35;
object[] s38 = new;
object[] s33 = s34 == s37 ? s38 : s34._items;
return (uint)(2 * s33.Length) < 2146435072u;
return objs.Length == 8;
Stack s40 = new;
List<object> s41 = new;
List<object> s39 = stack_stack == s40 ? s41 : stack_stack.items;
return methodof(s39.get_Count) == methodof(List<object>.get_Count);
Stack s43 = new;
List<object> s44 = new;
List<object> s42 = stack_stack == s43 ? s44 : stack_stack.items;
return methodof(s42.Add) == methodof(List<object>.Add);
Stack s48 = new;
List<object> s49 = new;
List<object> s47 = stack_stack == s48 ? s49 : stack_stack.items;
List<object> s46 = s47;
object[] s50 = new;
object[] s45 = s46 == s49 ? s50 : s46._items;
int s51 = s46 == s49 ? 8 : s46._size;
return 2 * s45.Length >= 1 + s51;
Stack s55 = new;
List<object> s56 = new;
List<object> s54 = stack_stack == s55 ? s56 : stack_stack.items;
List<object> s53 = s54;
object[] s57 = new;
object[] s52 = s53 == s56 ? s57 : s53._items;
int s58 = s53 == s56 ? 8 : s53._size;
return 2 * s52.Length >= s58;
Stack s63 = new;
List<object> s64 = new;
List<object> s62 = stack_stack == s63 ? s64 : stack_stack.items;
List<object> s61 = s62;
object[] s65 = new;
object[] s60 = s61 == s64 ? s65 : s61._items;
int s59 = s60.Length;
return 2 * s59 != s59;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: System.Collections.Generic.List`1.set_Capacity at 0x001b"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s6 = new;
Stack s5 = stack == s6 ? stack_stack : stack.stack;
Stack s4 = s5;
List<object> s7 = new;
List<object> s3 = s4 == (Stack)s6 ? s7 : s4.items;
List<object> s2 = s3;
object[] s8 = new;
object[] s1 = s2 == s7 ? s8 : s2._items;
int s0 = s1.Length;
return 2 * s0 == s0;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 8 : s9._size;
return s8 != 10;
Stack s16 = new;
List<object> s17 = new;
List<object> s15 = stack_stack == s16 ? s17 : stack_stack.items;
List<object> s14 = s15;
int s13 = s14 == s17 ? 8 : s14._size;
object[] s19 = new;
object[] s18 = s14 == s17 ? s19 : s14._items;
return s13 == s18.Length;
Stack s23 = new;
List<object> s24 = new;
List<object> s22 = stack_stack == s23 ? s24 : stack_stack.items;
List<object> s21 = s22;
object[] s25 = new;
object[] s20 = s21 == s24 ? s25 : s21._items;
int s26 = s21 == s24 ? 8 : s21._size;
return s20.Length < 1 + s26;
Stack s30 = new;
List<object> s31 = new;
List<object> s29 = stack_stack == s30 ? s31 : stack_stack.items;
List<object> s28 = s29;
object[] s32 = new;
object[] s27 = s28 == s31 ? s32 : s28._items;
return s27.Length != 0;
Stack s36 = new;
List<object> s37 = new;
List<object> s35 = stack_stack == s36 ? s37 : stack_stack.items;
List<object> s34 = s35;
object[] s38 = new;
object[] s33 = s34 == s37 ? s38 : s34._items;
return (uint)(2 * s33.Length) < 2146435072u;
return objs.Length == 8;
Stack s40 = new;
List<object> s41 = new;
List<object> s39 = stack_stack == s40 ? s41 : stack_stack.items;
return methodof(s39.get_Count) == methodof(List<object>.get_Count);
Stack s43 = new;
List<object> s44 = new;
List<object> s42 = stack_stack == s43 ? s44 : stack_stack.items;
return methodof(s42.Add) == methodof(List<object>.Add);
Stack s48 = new;
List<object> s49 = new;
List<object> s47 = stack_stack == s48 ? s49 : stack_stack.items;
List<object> s46 = s47;
object[] s50 = new;
object[] s45 = s46 == s49 ? s50 : s46._items;
int s51 = s46 == s49 ? 8 : s46._size;
return 2 * s45.Length >= 1 + s51;
Stack s55 = new;
List<object> s56 = new;
List<object> s54 = stack_stack == s55 ? s56 : stack_stack.items;
List<object> s53 = s54;
object[] s57 = new;
object[] s52 = s53 == s56 ? s57 : s53._items;
int s58 = s53 == s56 ? 8 : s53._size;
return 2 * s52.Length >= s58;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: System.Collections.Generic.List`1.EnsureCapacity at 0x0029"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
object[] s7 = new;
object[] s0 = s1 == s6 ? s7 : s1._items;
return 2146435071u < (uint)(2 * s0.Length);

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 8 : s9._size;
return s8 != 10;
Stack s16 = new;
List<object> s17 = new;
List<object> s15 = stack_stack == s16 ? s17 : stack_stack.items;
List<object> s14 = s15;
int s13 = s14 == s17 ? 8 : s14._size;
object[] s19 = new;
object[] s18 = s14 == s17 ? s19 : s14._items;
return s13 == s18.Length;
Stack s23 = new;
List<object> s24 = new;
List<object> s22 = stack_stack == s23 ? s24 : stack_stack.items;
List<object> s21 = s22;
object[] s25 = new;
object[] s20 = s21 == s24 ? s25 : s21._items;
int s26 = s21 == s24 ? 8 : s21._size;
return s20.Length < 1 + s26;
Stack s30 = new;
List<object> s31 = new;
List<object> s29 = stack_stack == s30 ? s31 : stack_stack.items;
List<object> s28 = s29;
object[] s32 = new;
object[] s27 = s28 == s31 ? s32 : s28._items;
return s27.Length != 0;
return objs.Length == 8;
Stack s34 = new;
List<object> s35 = new;
List<object> s33 = stack_stack == s34 ? s35 : stack_stack.items;
return methodof(s33.get_Count) == methodof(List<object>.get_Count);
Stack s37 = new;
List<object> s38 = new;
List<object> s36 = stack_stack == s37 ? s38 : stack_stack.items;
return methodof(s36.Add) == methodof(List<object>.Add);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: __InstrumentedSummarizers.System.Array.Copy at 0x0041"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
object[] s7 = new;
object[] s0 = s1 == s6 ? s7 : s1._items;
int s8 = s1 == s6 ? 8 : s1._size;
return s0.Length < s8;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 8 : s9._size;
return s8 != 10;
Stack s16 = new;
List<object> s17 = new;
List<object> s15 = stack_stack == s16 ? s17 : stack_stack.items;
List<object> s14 = s15;
int s13 = s14 == s17 ? 8 : s14._size;
object[] s19 = new;
object[] s18 = s14 == s17 ? s19 : s14._items;
return s13 == s18.Length;
Stack s23 = new;
List<object> s24 = new;
List<object> s22 = stack_stack == s23 ? s24 : stack_stack.items;
List<object> s21 = s22;
object[] s25 = new;
object[] s20 = s21 == s24 ? s25 : s21._items;
int s26 = s21 == s24 ? 8 : s21._size;
return s20.Length < 1 + s26;
Stack s30 = new;
List<object> s31 = new;
List<object> s29 = stack_stack == s30 ? s31 : stack_stack.items;
List<object> s28 = s29;
object[] s32 = new;
object[] s27 = s28 == s31 ? s32 : s28._items;
return s27.Length != 0;
Stack s36 = new;
List<object> s37 = new;
List<object> s35 = stack_stack == s36 ? s37 : stack_stack.items;
List<object> s34 = s35;
object[] s38 = new;
object[] s33 = s34 == s37 ? s38 : s34._items;
return (uint)(2 * s33.Length) < 2146435072u;
Stack s42 = new;
List<object> s43 = new;
List<object> s41 = stack_stack == s42 ? s43 : stack_stack.items;
List<object> s40 = s41;
object[] s44 = new;
object[] s39 = s40 == s43 ? s44 : s40._items;
return 0 < 2 * s39.Length;
Stack s48 = new;
List<object> s49 = new;
List<object> s47 = stack_stack == s48 ? s49 : stack_stack.items;
List<object> s46 = s47;
int s45 = s46 == s49 ? 8 : s46._size;
return 0 < s45;
Stack s53 = new;
List<object> s54 = new;
List<object> s52 = stack_stack == s53 ? s54 : stack_stack.items;
List<object> s51 = s52;
object[] s55 = new;
object[] s50 = s51 == s54 ? s55 : s51._items;
return s50 != (object[])null;
return objs.Length == 8;
Stack s57 = new;
List<object> s58 = new;
List<object> s56 = stack_stack == s57 ? s58 : stack_stack.items;
return methodof(s56.get_Count) == methodof(List<object>.get_Count);
Stack s60 = new;
List<object> s61 = new;
List<object> s59 = stack_stack == s60 ? s61 : stack_stack.items;
return methodof(s59.Add) == methodof(List<object>.Add);
Stack s65 = new;
List<object> s66 = new;
List<object> s64 = stack_stack == s65 ? s66 : stack_stack.items;
List<object> s63 = s64;
object[] s67 = new;
object[] s62 = s63 == s66 ? s67 : s63._items;
int s68 = s63 == s66 ? 8 : s63._size;
return 2 * s62.Length >= 1 + s68;
Stack s72 = new;
List<object> s73 = new;
List<object> s71 = stack_stack == s72 ? s73 : stack_stack.items;
List<object> s70 = s71;
object[] s74 = new;
object[] s69 = s70 == s73 ? s74 : s70._items;
int s75 = s70 == s73 ? 8 : s70._size;
return 2 * s69.Length >= s75;
Stack s80 = new;
List<object> s81 = new;
List<object> s79 = stack_stack == s80 ? s81 : stack_stack.items;
List<object> s78 = s79;
object[] s82 = new;
object[] s77 = s78 == s81 ? s82 : s78._items;
int s76 = s77.Length;
return 2 * s76 != s76;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.Push at 0x0008"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return methodof(s0.Add) != methodof(List<object>.Add);

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 1 : s9._size;
return s8 != 10;
return objs.Length == 1;
Stack s14 = new;
List<object> s15 = new;
List<object> s13 = stack_stack == s14 ? s15 : stack_stack.items;
return methodof(s13.get_Count) == methodof(List<object>.get_Count);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.get_Count at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return s0 == (List<object>)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
return objs.Length == 3;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStack.Push at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s1 = new;
Stack s0 = stack == s1 ? stack_stack : stack.stack;
return s0 == (Stack)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length == 1;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: __InstrumentedSummarizers.System.Array.Copy at 0x0009"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
object[] s7 = new;
object[] s0 = s1 == s6 ? s7 : s1._items;
return s0 == (object[])null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 8 : s9._size;
return s8 != 10;
Stack s16 = new;
List<object> s17 = new;
List<object> s15 = stack_stack == s16 ? s17 : stack_stack.items;
List<object> s14 = s15;
int s13 = s14 == s17 ? 8 : s14._size;
object[] s19 = new;
object[] s18 = s14 == s17 ? s19 : s14._items;
return s13 == s18.Length;
Stack s23 = new;
List<object> s24 = new;
List<object> s22 = stack_stack == s23 ? s24 : stack_stack.items;
List<object> s21 = s22;
object[] s25 = new;
object[] s20 = s21 == s24 ? s25 : s21._items;
int s26 = s21 == s24 ? 8 : s21._size;
return s20.Length < 1 + s26;
Stack s30 = new;
List<object> s31 = new;
List<object> s29 = stack_stack == s30 ? s31 : stack_stack.items;
List<object> s28 = s29;
object[] s32 = new;
object[] s27 = s28 == s31 ? s32 : s28._items;
return s27.Length != 0;
Stack s36 = new;
List<object> s37 = new;
List<object> s35 = stack_stack == s36 ? s37 : stack_stack.items;
List<object> s34 = s35;
object[] s38 = new;
object[] s33 = s34 == s37 ? s38 : s34._items;
return (uint)(2 * s33.Length) < 2146435072u;
Stack s42 = new;
List<object> s43 = new;
List<object> s41 = stack_stack == s42 ? s43 : stack_stack.items;
List<object> s40 = s41;
object[] s44 = new;
object[] s39 = s40 == s43 ? s44 : s40._items;
return 0 < 2 * s39.Length;
Stack s48 = new;
List<object> s49 = new;
List<object> s47 = stack_stack == s48 ? s49 : stack_stack.items;
List<object> s46 = s47;
int s45 = s46 == s49 ? 8 : s46._size;
return 0 < s45;
return objs.Length == 8;
Stack s51 = new;
List<object> s52 = new;
List<object> s50 = stack_stack == s51 ? s52 : stack_stack.items;
return methodof(s50.get_Count) == methodof(List<object>.get_Count);
Stack s54 = new;
List<object> s55 = new;
List<object> s53 = stack_stack == s54 ? s55 : stack_stack.items;
return methodof(s53.Add) == methodof(List<object>.Add);
Stack s59 = new;
List<object> s60 = new;
List<object> s58 = stack_stack == s59 ? s60 : stack_stack.items;
List<object> s57 = s58;
object[] s61 = new;
object[] s56 = s57 == s60 ? s61 : s57._items;
int s62 = s57 == s60 ? 8 : s57._size;
return 2 * s56.Length >= 1 + s62;
Stack s66 = new;
List<object> s67 = new;
List<object> s65 = stack_stack == s66 ? s67 : stack_stack.items;
List<object> s64 = s65;
object[] s68 = new;
object[] s63 = s64 == s67 ? s68 : s64._items;
int s69 = s64 == s67 ? 8 : s64._size;
return 2 * s63.Length >= s69;
Stack s74 = new;
List<object> s75 = new;
List<object> s73 = stack_stack == s74 ? s75 : stack_stack.items;
List<object> s72 = s73;
object[] s76 = new;
object[] s71 = s72 == s75 ? s76 : s72._items;
int s70 = s71.Length;
return 2 * s70 != s70;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: System.Collections.Generic.List`1.EnsureCapacity at 0x0033"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
object[] s7 = new;
object[] s0 = s1 == s6 ? s7 : s1._items;
int s8 = s1 == s6 ? 4 : s1._size;
return 2 * s0.Length < 1 + s8;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 4 : s9._size;
return s8 != 10;
Stack s16 = new;
List<object> s17 = new;
List<object> s15 = stack_stack == s16 ? s17 : stack_stack.items;
List<object> s14 = s15;
int s13 = s14 == s17 ? 4 : s14._size;
object[] s19 = new;
object[] s18 = s14 == s17 ? s19 : s14._items;
return s13 == s18.Length;
Stack s23 = new;
List<object> s24 = new;
List<object> s22 = stack_stack == s23 ? s24 : stack_stack.items;
List<object> s21 = s22;
object[] s25 = new;
object[] s20 = s21 == s24 ? s25 : s21._items;
int s26 = s21 == s24 ? 4 : s21._size;
return s20.Length < 1 + s26;
Stack s30 = new;
List<object> s31 = new;
List<object> s29 = stack_stack == s30 ? s31 : stack_stack.items;
List<object> s28 = s29;
object[] s32 = new;
object[] s27 = s28 == s31 ? s32 : s28._items;
return s27.Length != 0;
Stack s36 = new;
List<object> s37 = new;
List<object> s35 = stack_stack == s36 ? s37 : stack_stack.items;
List<object> s34 = s35;
object[] s38 = new;
object[] s33 = s34 == s37 ? s38 : s34._items;
return (uint)(2 * s33.Length) < 2146435072u;
return objs.Length == 4;
Stack s40 = new;
List<object> s41 = new;
List<object> s39 = stack_stack == s40 ? s41 : stack_stack.items;
return methodof(s39.get_Count) == methodof(List<object>.get_Count);
Stack s43 = new;
List<object> s44 = new;
List<object> s42 = stack_stack == s43 ? s44 : stack_stack.items;
return methodof(s42.Add) == methodof(List<object>.Add);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: System.Collections.Generic.List`1.EnsureCapacity at 0x0009"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
object[] s7 = new;
object[] s0 = s1 == s6 ? s7 : s1._items;
int s8 = s1 == s6 ? 4 : s1._size;
return s0.Length >= 1 + s8;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 4 : s9._size;
return s8 != 10;
Stack s16 = new;
List<object> s17 = new;
List<object> s15 = stack_stack == s16 ? s17 : stack_stack.items;
List<object> s14 = s15;
int s13 = s14 == s17 ? 4 : s14._size;
object[] s19 = new;
object[] s18 = s14 == s17 ? s19 : s14._items;
return s13 == s18.Length;
return objs.Length == 4;
Stack s21 = new;
List<object> s22 = new;
List<object> s20 = stack_stack == s21 ? s22 : stack_stack.items;
return methodof(s20.get_Count) == methodof(List<object>.get_Count);
Stack s24 = new;
List<object> s25 = new;
List<object> s23 = stack_stack == s24 ? s25 : stack_stack.items;
return methodof(s23.Add) == methodof(List<object>.Add);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: System.Collections.Generic.List`1.set_Capacity at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
object[] s7 = new;
object[] s0 = s1 == s6 ? s7 : s1._items;
int s8 = s1 == s6 ? 4 : s1._size;
return 2 * s0.Length < s8;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 4 : s9._size;
return s8 != 10;
Stack s16 = new;
List<object> s17 = new;
List<object> s15 = stack_stack == s16 ? s17 : stack_stack.items;
List<object> s14 = s15;
int s13 = s14 == s17 ? 4 : s14._size;
object[] s19 = new;
object[] s18 = s14 == s17 ? s19 : s14._items;
return s13 == s18.Length;
Stack s23 = new;
List<object> s24 = new;
List<object> s22 = stack_stack == s23 ? s24 : stack_stack.items;
List<object> s21 = s22;
object[] s25 = new;
object[] s20 = s21 == s24 ? s25 : s21._items;
int s26 = s21 == s24 ? 4 : s21._size;
return s20.Length < 1 + s26;
Stack s30 = new;
List<object> s31 = new;
List<object> s29 = stack_stack == s30 ? s31 : stack_stack.items;
List<object> s28 = s29;
object[] s32 = new;
object[] s27 = s28 == s31 ? s32 : s28._items;
return s27.Length != 0;
Stack s36 = new;
List<object> s37 = new;
List<object> s35 = stack_stack == s36 ? s37 : stack_stack.items;
List<object> s34 = s35;
object[] s38 = new;
object[] s33 = s34 == s37 ? s38 : s34._items;
return (uint)(2 * s33.Length) < 2146435072u;
return objs.Length == 4;
Stack s40 = new;
List<object> s41 = new;
List<object> s39 = stack_stack == s40 ? s41 : stack_stack.items;
return methodof(s39.get_Count) == methodof(List<object>.get_Count);
Stack s43 = new;
List<object> s44 = new;
List<object> s42 = stack_stack == s43 ? s44 : stack_stack.items;
return methodof(s42.Add) == methodof(List<object>.Add);
Stack s48 = new;
List<object> s49 = new;
List<object> s47 = stack_stack == s48 ? s49 : stack_stack.items;
List<object> s46 = s47;
object[] s50 = new;
object[] s45 = s46 == s49 ? s50 : s46._items;
int s51 = s46 == s49 ? 4 : s46._size;
return 2 * s45.Length >= 1 + s51;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: System.Collections.Generic.List`1.EnsureCapacity at 0x0013"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
object[] s7 = new;
object[] s0 = s1 == s6 ? s7 : s1._items;
return s0.Length == 0;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 8 : s9._size;
return s8 != 10;
Stack s16 = new;
List<object> s17 = new;
List<object> s15 = stack_stack == s16 ? s17 : stack_stack.items;
List<object> s14 = s15;
int s13 = s14 == s17 ? 8 : s14._size;
object[] s19 = new;
object[] s18 = s14 == s17 ? s19 : s14._items;
return s13 == s18.Length;
Stack s23 = new;
List<object> s24 = new;
List<object> s22 = stack_stack == s23 ? s24 : stack_stack.items;
List<object> s21 = s22;
object[] s25 = new;
object[] s20 = s21 == s24 ? s25 : s21._items;
int s26 = s21 == s24 ? 8 : s21._size;
return s20.Length < 1 + s26;
return objs.Length == 8;
Stack s28 = new;
List<object> s29 = new;
List<object> s27 = stack_stack == s28 ? s29 : stack_stack.items;
return methodof(s27.get_Count) == methodof(List<object>.get_Count);
Stack s31 = new;
List<object> s32 = new;
List<object> s30 = stack_stack == s31 ? s32 : stack_stack.items;
return methodof(s30.Add) == methodof(List<object>.Add);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: System.Collections.Generic.List`1.Add at 0x000e"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
int s0 = s1 == s6 ? 4 : s1._size;
object[] s8 = new;
object[] s7 = s1 == s6 ? s8 : s1._items;
return s0 != s7.Length;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 4 : s9._size;
return s8 != 10;
return objs.Length == 4;
Stack s14 = new;
List<object> s15 = new;
List<object> s13 = stack_stack == s14 ? s15 : stack_stack.items;
return methodof(s13.get_Count) == methodof(List<object>.get_Count);
Stack s17 = new;
List<object> s18 = new;
List<object> s16 = stack_stack == s17 ? s18 : stack_stack.items;
return methodof(s16.Add) == methodof(List<object>.Add);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.Push at 0x0008"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return methodof(s0.Add) != methodof(List<object>.Add);

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 4 : s9._size;
return s8 != 10;
return objs.Length == 4;
Stack s14 = new;
List<object> s15 = new;
List<object> s13 = stack_stack == s14 ? s15 : stack_stack.items;
return methodof(s13.get_Count) == methodof(List<object>.get_Count);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: System.Collections.Generic.List`1.EnsureCapacity at 0x0033"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
object[] s7 = new;
object[] s0 = s1 == s6 ? s7 : s1._items;
int s8 = s1 == s6 ? 8 : s1._size;
return 2 * s0.Length < 1 + s8;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 8 : s9._size;
return s8 != 10;
Stack s16 = new;
List<object> s17 = new;
List<object> s15 = stack_stack == s16 ? s17 : stack_stack.items;
List<object> s14 = s15;
int s13 = s14 == s17 ? 8 : s14._size;
object[] s19 = new;
object[] s18 = s14 == s17 ? s19 : s14._items;
return s13 == s18.Length;
Stack s23 = new;
List<object> s24 = new;
List<object> s22 = stack_stack == s23 ? s24 : stack_stack.items;
List<object> s21 = s22;
object[] s25 = new;
object[] s20 = s21 == s24 ? s25 : s21._items;
int s26 = s21 == s24 ? 8 : s21._size;
return s20.Length < 1 + s26;
Stack s30 = new;
List<object> s31 = new;
List<object> s29 = stack_stack == s30 ? s31 : stack_stack.items;
List<object> s28 = s29;
object[] s32 = new;
object[] s27 = s28 == s31 ? s32 : s28._items;
return s27.Length != 0;
Stack s36 = new;
List<object> s37 = new;
List<object> s35 = stack_stack == s36 ? s37 : stack_stack.items;
List<object> s34 = s35;
object[] s38 = new;
object[] s33 = s34 == s37 ? s38 : s34._items;
return (uint)(2 * s33.Length) < 2146435072u;
return objs.Length == 8;
Stack s40 = new;
List<object> s41 = new;
List<object> s39 = stack_stack == s40 ? s41 : stack_stack.items;
return methodof(s39.get_Count) == methodof(List<object>.get_Count);
Stack s43 = new;
List<object> s44 = new;
List<object> s42 = stack_stack == s43 ? s44 : stack_stack.items;
return methodof(s42.Add) == methodof(List<object>.Add);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: System.Collections.Generic.List`1.set_Capacity at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
object[] s7 = new;
object[] s0 = s1 == s6 ? s7 : s1._items;
int s8 = s1 == s6 ? 8 : s1._size;
return 2 * s0.Length < s8;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 8 : s9._size;
return s8 != 10;
Stack s16 = new;
List<object> s17 = new;
List<object> s15 = stack_stack == s16 ? s17 : stack_stack.items;
List<object> s14 = s15;
int s13 = s14 == s17 ? 8 : s14._size;
object[] s19 = new;
object[] s18 = s14 == s17 ? s19 : s14._items;
return s13 == s18.Length;
Stack s23 = new;
List<object> s24 = new;
List<object> s22 = stack_stack == s23 ? s24 : stack_stack.items;
List<object> s21 = s22;
object[] s25 = new;
object[] s20 = s21 == s24 ? s25 : s21._items;
int s26 = s21 == s24 ? 8 : s21._size;
return s20.Length < 1 + s26;
Stack s30 = new;
List<object> s31 = new;
List<object> s29 = stack_stack == s30 ? s31 : stack_stack.items;
List<object> s28 = s29;
object[] s32 = new;
object[] s27 = s28 == s31 ? s32 : s28._items;
return s27.Length != 0;
Stack s36 = new;
List<object> s37 = new;
List<object> s35 = stack_stack == s36 ? s37 : stack_stack.items;
List<object> s34 = s35;
object[] s38 = new;
object[] s33 = s34 == s37 ? s38 : s34._items;
return (uint)(2 * s33.Length) < 2146435072u;
return objs.Length == 8;
Stack s40 = new;
List<object> s41 = new;
List<object> s39 = stack_stack == s40 ? s41 : stack_stack.items;
return methodof(s39.get_Count) == methodof(List<object>.get_Count);
Stack s43 = new;
List<object> s44 = new;
List<object> s42 = stack_stack == s43 ? s44 : stack_stack.items;
return methodof(s42.Add) == methodof(List<object>.Add);
Stack s48 = new;
List<object> s49 = new;
List<object> s47 = stack_stack == s48 ? s49 : stack_stack.items;
List<object> s46 = s47;
object[] s50 = new;
object[] s45 = s46 == s49 ? s50 : s46._items;
int s51 = s46 == s49 ? 8 : s46._size;
return 2 * s45.Length >= 1 + s51;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStackTest.TestPush at 0x0003"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[return stack == (FixedSizeStack)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length == 4;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStackTest.TestPush at 0x0003"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[return stack == (FixedSizeStack)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length == 3;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStackTest.TestPush at 0x0003"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[return stack == (FixedSizeStack)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length == 5;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: System.Collections.Generic.List`1.EnsureCapacity at 0x0009"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
object[] s7 = new;
object[] s0 = s1 == s6 ? s7 : s1._items;
int s8 = s1 == s6 ? 8 : s1._size;
return s0.Length >= 1 + s8;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 8 : s9._size;
return s8 != 10;
Stack s16 = new;
List<object> s17 = new;
List<object> s15 = stack_stack == s16 ? s17 : stack_stack.items;
List<object> s14 = s15;
int s13 = s14 == s17 ? 8 : s14._size;
object[] s19 = new;
object[] s18 = s14 == s17 ? s19 : s14._items;
return s13 == s18.Length;
return objs.Length == 8;
Stack s21 = new;
List<object> s22 = new;
List<object> s20 = stack_stack == s21 ? s22 : stack_stack.items;
return methodof(s20.get_Count) == methodof(List<object>.get_Count);
Stack s24 = new;
List<object> s25 = new;
List<object> s23 = stack_stack == s24 ? s25 : stack_stack.items;
return methodof(s23.Add) == methodof(List<object>.Add);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStackTest.TestPush at 0x0003"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[return stack == (FixedSizeStack)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length == 6;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: System.Collections.Generic.List`1.Add at 0x000e"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
int s0 = s1 == s6 ? 8 : s1._size;
object[] s8 = new;
object[] s7 = s1 == s6 ? s8 : s1._items;
return s0 != s7.Length;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 8 : s9._size;
return s8 != 10;
return objs.Length == 8;
Stack s14 = new;
List<object> s15 = new;
List<object> s13 = stack_stack == s14 ? s15 : stack_stack.items;
return methodof(s13.get_Count) == methodof(List<object>.get_Count);
Stack s17 = new;
List<object> s18 = new;
List<object> s16 = stack_stack == s17 ? s18 : stack_stack.items;
return methodof(s16.Add) == methodof(List<object>.Add);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStack.Push at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s1 = new;
Stack s0 = stack == s1 ? stack_stack : stack.stack;
return s0 == (Stack)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length == 2;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: System.Collections.Generic.List`1.EnsureCapacity at 0x0013"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
object[] s7 = new;
object[] s0 = s1 == s6 ? s7 : s1._items;
return s0.Length == 0;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 4 : s9._size;
return s8 != 10;
Stack s16 = new;
List<object> s17 = new;
List<object> s15 = stack_stack == s16 ? s17 : stack_stack.items;
List<object> s14 = s15;
int s13 = s14 == s17 ? 4 : s14._size;
object[] s19 = new;
object[] s18 = s14 == s17 ? s19 : s14._items;
return s13 == s18.Length;
Stack s23 = new;
List<object> s24 = new;
List<object> s22 = stack_stack == s23 ? s24 : stack_stack.items;
List<object> s21 = s22;
object[] s25 = new;
object[] s20 = s21 == s24 ? s25 : s21._items;
int s26 = s21 == s24 ? 4 : s21._size;
return s20.Length < 1 + s26;
return objs.Length == 4;
Stack s28 = new;
List<object> s29 = new;
List<object> s27 = stack_stack == s28 ? s29 : stack_stack.items;
return methodof(s27.get_Count) == methodof(List<object>.get_Count);
Stack s31 = new;
List<object> s32 = new;
List<object> s30 = stack_stack == s31 ? s32 : stack_stack.items;
return methodof(s30.Add) == methodof(List<object>.Add);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStackTest.TestPush at 0x0003"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[return stack == (FixedSizeStack)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length == 7;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.Push at 0x0008"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return methodof(s0.Add) != methodof(List<object>.Add);

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 2 : s9._size;
return s8 != 10;
return objs.Length == 2;
Stack s14 = new;
List<object> s15 = new;
List<object> s13 = stack_stack == s14 ? s15 : stack_stack.items;
return methodof(s13.get_Count) == methodof(List<object>.get_Count);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStack.Push at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s1 = new;
Stack s0 = stack == s1 ? stack_stack : stack.stack;
return s0 == (Stack)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length == 3;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStack.Push at 0x0015"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
int s0 = s1 == s6 ? 3 : s1._size;
return s0 == 10;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
return objs.Length == 3;
Stack s9 = new;
List<object> s10 = new;
List<object> s8 = stack_stack == s9 ? s10 : stack_stack.items;
return methodof(s8.get_Count) == methodof(List<object>.get_Count);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStack.Push at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s1 = new;
Stack s0 = stack == s1 ? stack_stack : stack.stack;
return s0 == (Stack)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length == 4;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStack.Push at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s1 = new;
Stack s0 = stack == s1 ? stack_stack : stack.stack;
return s0 == (Stack)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length == 5;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.Push at 0x0008"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return methodof(s0.Add) != methodof(List<object>.Add);

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 5 : s9._size;
return s8 != 10;
return objs.Length == 5;
Stack s14 = new;
List<object> s15 = new;
List<object> s13 = stack_stack == s14 ? s15 : stack_stack.items;
return methodof(s13.get_Count) == methodof(List<object>.get_Count);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.get_Count at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return s0 == (List<object>)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
return objs.Length == 4;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.Push at 0x0008"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return methodof(s0.Add) != methodof(List<object>.Add);

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 3 : s9._size;
return s8 != 10;
return objs.Length == 3;
Stack s14 = new;
List<object> s15 = new;
List<object> s13 = stack_stack == s14 ? s15 : stack_stack.items;
return methodof(s13.get_Count) == methodof(List<object>.get_Count);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStackTest.TestPush at 0x0003"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[return stack == (FixedSizeStack)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length == 8;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: System.Collections.Generic.List`1.set_Capacity at 0x002f"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
int s0 = s1 == s6 ? 4 : s1._size;
return s0 < 1;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 4 : s9._size;
return s8 != 10;
Stack s16 = new;
List<object> s17 = new;
List<object> s15 = stack_stack == s16 ? s17 : stack_stack.items;
List<object> s14 = s15;
int s13 = s14 == s17 ? 4 : s14._size;
object[] s19 = new;
object[] s18 = s14 == s17 ? s19 : s14._items;
return s13 == s18.Length;
Stack s23 = new;
List<object> s24 = new;
List<object> s22 = stack_stack == s23 ? s24 : stack_stack.items;
List<object> s21 = s22;
object[] s25 = new;
object[] s20 = s21 == s24 ? s25 : s21._items;
int s26 = s21 == s24 ? 4 : s21._size;
return s20.Length < 1 + s26;
Stack s30 = new;
List<object> s31 = new;
List<object> s29 = stack_stack == s30 ? s31 : stack_stack.items;
List<object> s28 = s29;
object[] s32 = new;
object[] s27 = s28 == s31 ? s32 : s28._items;
return s27.Length != 0;
Stack s36 = new;
List<object> s37 = new;
List<object> s35 = stack_stack == s36 ? s37 : stack_stack.items;
List<object> s34 = s35;
object[] s38 = new;
object[] s33 = s34 == s37 ? s38 : s34._items;
return (uint)(2 * s33.Length) < 2146435072u;
Stack s42 = new;
List<object> s43 = new;
List<object> s41 = stack_stack == s42 ? s43 : stack_stack.items;
List<object> s40 = s41;
object[] s44 = new;
object[] s39 = s40 == s43 ? s44 : s40._items;
return 0 < 2 * s39.Length;
return objs.Length == 4;
Stack s46 = new;
List<object> s47 = new;
List<object> s45 = stack_stack == s46 ? s47 : stack_stack.items;
return methodof(s45.get_Count) == methodof(List<object>.get_Count);
Stack s49 = new;
List<object> s50 = new;
List<object> s48 = stack_stack == s49 ? s50 : stack_stack.items;
return methodof(s48.Add) == methodof(List<object>.Add);
Stack s54 = new;
List<object> s55 = new;
List<object> s53 = stack_stack == s54 ? s55 : stack_stack.items;
List<object> s52 = s53;
object[] s56 = new;
object[] s51 = s52 == s55 ? s56 : s52._items;
int s57 = s52 == s55 ? 4 : s52._size;
return 2 * s51.Length >= 1 + s57;
Stack s61 = new;
List<object> s62 = new;
List<object> s60 = stack_stack == s61 ? s62 : stack_stack.items;
List<object> s59 = s60;
object[] s63 = new;
object[] s58 = s59 == s62 ? s63 : s59._items;
int s64 = s59 == s62 ? 4 : s59._size;
return 2 * s58.Length >= s64;
Stack s69 = new;
List<object> s70 = new;
List<object> s68 = stack_stack == s69 ? s70 : stack_stack.items;
List<object> s67 = s68;
object[] s71 = new;
object[] s66 = s67 == s70 ? s71 : s67._items;
int s65 = s66.Length;
return 2 * s65 != s65;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: System.Collections.Generic.List`1.Add at 0x000e"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
int s0 = s1 == s6 ? 1 : s1._size;
object[] s8 = new;
object[] s7 = s1 == s6 ? s8 : s1._items;
return s0 == s7.Length;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 1 : s9._size;
return s8 != 10;
return objs.Length == 1;
Stack s14 = new;
List<object> s15 = new;
List<object> s13 = stack_stack == s14 ? s15 : stack_stack.items;
return methodof(s13.get_Count) == methodof(List<object>.get_Count);
Stack s17 = new;
List<object> s18 = new;
List<object> s16 = stack_stack == s17 ? s18 : stack_stack.items;
return methodof(s16.Add) == methodof(List<object>.Add);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStack.Push at 0x0015"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
int s0 = s1 == s6 ? 1 : s1._size;
return s0 == 10;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
return objs.Length == 1;
Stack s9 = new;
List<object> s10 = new;
List<object> s8 = stack_stack == s9 ? s10 : stack_stack.items;
return methodof(s8.get_Count) == methodof(List<object>.get_Count);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: System.Collections.Generic.List`1.set_Capacity at 0x002f"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
int s0 = s1 == s6 ? 8 : s1._size;
return s0 < 1;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 8 : s9._size;
return s8 != 10;
Stack s16 = new;
List<object> s17 = new;
List<object> s15 = stack_stack == s16 ? s17 : stack_stack.items;
List<object> s14 = s15;
int s13 = s14 == s17 ? 8 : s14._size;
object[] s19 = new;
object[] s18 = s14 == s17 ? s19 : s14._items;
return s13 == s18.Length;
Stack s23 = new;
List<object> s24 = new;
List<object> s22 = stack_stack == s23 ? s24 : stack_stack.items;
List<object> s21 = s22;
object[] s25 = new;
object[] s20 = s21 == s24 ? s25 : s21._items;
int s26 = s21 == s24 ? 8 : s21._size;
return s20.Length < 1 + s26;
Stack s30 = new;
List<object> s31 = new;
List<object> s29 = stack_stack == s30 ? s31 : stack_stack.items;
List<object> s28 = s29;
object[] s32 = new;
object[] s27 = s28 == s31 ? s32 : s28._items;
return s27.Length != 0;
Stack s36 = new;
List<object> s37 = new;
List<object> s35 = stack_stack == s36 ? s37 : stack_stack.items;
List<object> s34 = s35;
object[] s38 = new;
object[] s33 = s34 == s37 ? s38 : s34._items;
return (uint)(2 * s33.Length) < 2146435072u;
Stack s42 = new;
List<object> s43 = new;
List<object> s41 = stack_stack == s42 ? s43 : stack_stack.items;
List<object> s40 = s41;
object[] s44 = new;
object[] s39 = s40 == s43 ? s44 : s40._items;
return 0 < 2 * s39.Length;
return objs.Length == 8;
Stack s46 = new;
List<object> s47 = new;
List<object> s45 = stack_stack == s46 ? s47 : stack_stack.items;
return methodof(s45.get_Count) == methodof(List<object>.get_Count);
Stack s49 = new;
List<object> s50 = new;
List<object> s48 = stack_stack == s49 ? s50 : stack_stack.items;
return methodof(s48.Add) == methodof(List<object>.Add);
Stack s54 = new;
List<object> s55 = new;
List<object> s53 = stack_stack == s54 ? s55 : stack_stack.items;
List<object> s52 = s53;
object[] s56 = new;
object[] s51 = s52 == s55 ? s56 : s52._items;
int s57 = s52 == s55 ? 8 : s52._size;
return 2 * s51.Length >= 1 + s57;
Stack s61 = new;
List<object> s62 = new;
List<object> s60 = stack_stack == s61 ? s62 : stack_stack.items;
List<object> s59 = s60;
object[] s63 = new;
object[] s58 = s59 == s62 ? s63 : s59._items;
int s64 = s59 == s62 ? 8 : s59._size;
return 2 * s58.Length >= s64;
Stack s69 = new;
List<object> s70 = new;
List<object> s68 = stack_stack == s69 ? s70 : stack_stack.items;
List<object> s67 = s68;
object[] s71 = new;
object[] s66 = s67 == s70 ? s71 : s67._items;
int s65 = s66.Length;
return 2 * s65 != s65;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: System.Collections.Generic.List`1.Add at 0x000e"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
int s0 = s1 == s6 ? 5 : s1._size;
object[] s8 = new;
object[] s7 = s1 == s6 ? s8 : s1._items;
return s0 == s7.Length;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 5 : s9._size;
return s8 != 10;
return objs.Length == 5;
Stack s14 = new;
List<object> s15 = new;
List<object> s13 = stack_stack == s14 ? s15 : stack_stack.items;
return methodof(s13.get_Count) == methodof(List<object>.get_Count);
Stack s17 = new;
List<object> s18 = new;
List<object> s16 = stack_stack == s17 ? s18 : stack_stack.items;
return methodof(s16.Add) == methodof(List<object>.Add);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.get_Count at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return methodof(s0.get_Count) != methodof(List<object>.get_Count);

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length < 1;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStack.Push at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s1 = new;
Stack s0 = stack == s1 ? stack_stack : stack.stack;
return s0 == (Stack)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length == 6;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStack.Push at 0x0015"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
int s0 = s1 == s6 ? 4 : s1._size;
return s0 == 10;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
return objs.Length == 4;
Stack s9 = new;
List<object> s10 = new;
List<object> s8 = stack_stack == s9 ? s10 : stack_stack.items;
return methodof(s8.get_Count) == methodof(List<object>.get_Count);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.get_Count at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return s0 == (List<object>)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
return objs.Length == 1;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.get_Count at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return methodof(s0.get_Count) != methodof(List<object>.get_Count);

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
return objs.Length == 3;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStack.Push at 0x0015"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
int s0 = s1 == s6 ? 5 : s1._size;
return s0 == 10;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
return objs.Length == 5;
Stack s9 = new;
List<object> s10 = new;
List<object> s8 = stack_stack == s9 ? s10 : stack_stack.items;
return methodof(s8.get_Count) == methodof(List<object>.get_Count);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStackTest.TestPush at 0x0003"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[return stack == (FixedSizeStack)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length == 9;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStack.Push at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s1 = new;
Stack s0 = stack == s1 ? stack_stack : stack.stack;
return s0 == (Stack)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length == 8;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStackTest.TestPush at 0x0003"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[return stack == (FixedSizeStack)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length == 10;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStack.Push at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s1 = new;
Stack s0 = stack == s1 ? stack_stack : stack.stack;
return s0 == (Stack)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length == 7;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStackTest.TestPush at 0x0003"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[return stack == (FixedSizeStack)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length == 11;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStackTest.TestPush at 0x0003"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[return stack == (FixedSizeStack)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length == 12;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStackTest.TestPush at 0x0003"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[return stack == (FixedSizeStack)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length == 14;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.get_Count at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return s0 == (List<object>)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
return objs.Length == 5;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.Push at 0x0008"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return methodof(s0.Add) != methodof(List<object>.Add);

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 6 : s9._size;
return s8 != 10;
return objs.Length == 6;
Stack s14 = new;
List<object> s15 = new;
List<object> s13 = stack_stack == s14 ? s15 : stack_stack.items;
return methodof(s13.get_Count) == methodof(List<object>.get_Count);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStackTest.TestPush at 0x0003"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[return stack == (FixedSizeStack)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length == 13;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.Push at 0x0008"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return methodof(s0.Add) != methodof(List<object>.Add);

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 7 : s9._size;
return s8 != 10;
return objs.Length == 7;
Stack s14 = new;
List<object> s15 = new;
List<object> s13 = stack_stack == s14 ? s15 : stack_stack.items;
return methodof(s13.get_Count) == methodof(List<object>.get_Count);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: System.Collections.Generic.List`1.Add at 0x000e"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
int s0 = s1 == s6 ? 6 : s1._size;
object[] s8 = new;
object[] s7 = s1 == s6 ? s8 : s1._items;
return s0 == s7.Length;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 6 : s9._size;
return s8 != 10;
return objs.Length == 6;
Stack s14 = new;
List<object> s15 = new;
List<object> s13 = stack_stack == s14 ? s15 : stack_stack.items;
return methodof(s13.get_Count) == methodof(List<object>.get_Count);
Stack s17 = new;
List<object> s18 = new;
List<object> s16 = stack_stack == s17 ? s18 : stack_stack.items;
return methodof(s16.Add) == methodof(List<object>.Add);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStack.Push at 0x0015"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
int s0 = s1 == s6 ? 6 : s1._size;
return s0 == 10;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
return objs.Length == 6;
Stack s9 = new;
List<object> s10 = new;
List<object> s8 = stack_stack == s9 ? s10 : stack_stack.items;
return methodof(s8.get_Count) == methodof(List<object>.get_Count);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.get_Count at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return s0 == (List<object>)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
return objs.Length == 2;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.get_Count at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return methodof(s0.get_Count) != methodof(List<object>.get_Count);

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
return objs.Length == 4;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.get_Count at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return s0 == (List<object>)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
return objs.Length == 8;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.Push at 0x0008"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return methodof(s0.Add) != methodof(List<object>.Add);

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 9 : s9._size;
return s8 != 10;
return objs.Length == 9;
Stack s14 = new;
List<object> s15 = new;
List<object> s13 = stack_stack == s14 ? s15 : stack_stack.items;
return methodof(s13.get_Count) == methodof(List<object>.get_Count);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.Push at 0x0008"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return methodof(s0.Add) != methodof(List<object>.Add);

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 11 : s9._size;
return s8 != 10;
return objs.Length == 11;
Stack s14 = new;
List<object> s15 = new;
List<object> s13 = stack_stack == s14 ? s15 : stack_stack.items;
return methodof(s13.get_Count) == methodof(List<object>.get_Count);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: System.Collections.Generic.List`1.Add at 0x000e"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
int s0 = s1 == s6 ? 2 : s1._size;
object[] s8 = new;
object[] s7 = s1 == s6 ? s8 : s1._items;
return s0 == s7.Length;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 2 : s9._size;
return s8 != 10;
return objs.Length == 2;
Stack s14 = new;
List<object> s15 = new;
List<object> s13 = stack_stack == s14 ? s15 : stack_stack.items;
return methodof(s13.get_Count) == methodof(List<object>.get_Count);
Stack s17 = new;
List<object> s18 = new;
List<object> s16 = stack_stack == s17 ? s18 : stack_stack.items;
return methodof(s16.Add) == methodof(List<object>.Add);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStack.Push at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s1 = new;
Stack s0 = stack == s1 ? stack_stack : stack.stack;
return s0 == (Stack)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length == 9;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: System.Collections.Generic.List`1.Add at 0x000e"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
int s0 = s1 == s6 ? 3 : s1._size;
object[] s8 = new;
object[] s7 = s1 == s6 ? s8 : s1._items;
return s0 == s7.Length;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 3 : s9._size;
return s8 != 10;
return objs.Length == 3;
Stack s14 = new;
List<object> s15 = new;
List<object> s13 = stack_stack == s14 ? s15 : stack_stack.items;
return methodof(s13.get_Count) == methodof(List<object>.get_Count);
Stack s17 = new;
List<object> s18 = new;
List<object> s16 = stack_stack == s17 ? s18 : stack_stack.items;
return methodof(s16.Add) == methodof(List<object>.Add);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: System.Collections.Generic.List`1.Add at 0x000e"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
int s0 = s1 == s6 ? 7 : s1._size;
object[] s8 = new;
object[] s7 = s1 == s6 ? s8 : s1._items;
return s0 == s7.Length;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 7 : s9._size;
return s8 != 10;
return objs.Length == 7;
Stack s14 = new;
List<object> s15 = new;
List<object> s13 = stack_stack == s14 ? s15 : stack_stack.items;
return methodof(s13.get_Count) == methodof(List<object>.get_Count);
Stack s17 = new;
List<object> s18 = new;
List<object> s16 = stack_stack == s17 ? s18 : stack_stack.items;
return methodof(s16.Add) == methodof(List<object>.Add);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: System.Collections.Generic.List`1.Add at 0x000e"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
int s0 = s1 == s6 ? 9 : s1._size;
object[] s8 = new;
object[] s7 = s1 == s6 ? s8 : s1._items;
return s0 == s7.Length;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 9 : s9._size;
return s8 != 10;
return objs.Length == 9;
Stack s14 = new;
List<object> s15 = new;
List<object> s13 = stack_stack == s14 ? s15 : stack_stack.items;
return methodof(s13.get_Count) == methodof(List<object>.get_Count);
Stack s17 = new;
List<object> s18 = new;
List<object> s16 = stack_stack == s17 ? s18 : stack_stack.items;
return methodof(s16.Add) == methodof(List<object>.Add);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStack.Push at 0x0015"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
int s0 = s1 == s6 ? 2 : s1._size;
return s0 == 10;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
return objs.Length == 2;
Stack s9 = new;
List<object> s10 = new;
List<object> s8 = stack_stack == s9 ? s10 : stack_stack.items;
return methodof(s8.get_Count) == methodof(List<object>.get_Count);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStack.Push at 0x0015"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
int s0 = s1 == s6 ? 7 : s1._size;
return s0 == 10;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
return objs.Length == 7;
Stack s9 = new;
List<object> s10 = new;
List<object> s8 = stack_stack == s9 ? s10 : stack_stack.items;
return methodof(s8.get_Count) == methodof(List<object>.get_Count);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStack.Push at 0x0015"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
int s0 = s1 == s6 ? 8 : s1._size;
return s0 == 10;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
return objs.Length == 8;
Stack s9 = new;
List<object> s10 = new;
List<object> s8 = stack_stack == s9 ? s10 : stack_stack.items;
return methodof(s8.get_Count) == methodof(List<object>.get_Count);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.get_Count at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return s0 == (List<object>)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
return objs.Length == 9;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.get_Count at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return methodof(s0.get_Count) != methodof(List<object>.get_Count);

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
return objs.Length == 5;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStack.Push at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s1 = new;
Stack s0 = stack == s1 ? stack_stack : stack.stack;
return s0 == (Stack)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length == 10;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: System.Collections.Generic.List`1.Add at 0x000e"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
int s0 = s1 == s6 ? 11 : s1._size;
object[] s8 = new;
object[] s7 = s1 == s6 ? s8 : s1._items;
return s0 == s7.Length;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 11 : s9._size;
return s8 != 10;
return objs.Length == 11;
Stack s14 = new;
List<object> s15 = new;
List<object> s13 = stack_stack == s14 ? s15 : stack_stack.items;
return methodof(s13.get_Count) == methodof(List<object>.get_Count);
Stack s17 = new;
List<object> s18 = new;
List<object> s16 = stack_stack == s17 ? s18 : stack_stack.items;
return methodof(s16.Add) == methodof(List<object>.Add);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStack.Push at 0x0015"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
int s0 = s1 == s6 ? 9 : s1._size;
return s0 == 10;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
return objs.Length == 9;
Stack s9 = new;
List<object> s10 = new;
List<object> s8 = stack_stack == s9 ? s10 : stack_stack.items;
return methodof(s8.get_Count) == methodof(List<object>.get_Count);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStack.Push at 0x0015"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
int s0 = s1 == s6 ? 10 : s1._size;
return s0 != 10;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
return objs.Length == 10;
Stack s9 = new;
List<object> s10 = new;
List<object> s8 = stack_stack == s9 ? s10 : stack_stack.items;
return methodof(s8.get_Count) == methodof(List<object>.get_Count);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.Push at 0x0008"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return methodof(s0.Add) != methodof(List<object>.Add);

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 14 : s9._size;
return s8 != 10;
return objs.Length == 14;
Stack s14 = new;
List<object> s15 = new;
List<object> s13 = stack_stack == s14 ? s15 : stack_stack.items;
return methodof(s13.get_Count) == methodof(List<object>.get_Count);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.get_Count at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return s0 == (List<object>)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
return objs.Length == 6;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStack.Push at 0x0015"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
int s0 = s1 == s6 ? 11 : s1._size;
return s0 == 10;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
return objs.Length == 11;
Stack s9 = new;
List<object> s10 = new;
List<object> s8 = stack_stack == s9 ? s10 : stack_stack.items;
return methodof(s8.get_Count) == methodof(List<object>.get_Count);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStack.Push at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s1 = new;
Stack s0 = stack == s1 ? stack_stack : stack.stack;
return s0 == (Stack)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length == 12;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.Push at 0x0008"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return methodof(s0.Add) != methodof(List<object>.Add);

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 12 : s9._size;
return s8 != 10;
return objs.Length == 12;
Stack s14 = new;
List<object> s15 = new;
List<object> s13 = stack_stack == s14 ? s15 : stack_stack.items;
return methodof(s13.get_Count) == methodof(List<object>.get_Count);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: System.Collections.Generic.List`1.Add at 0x000e"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
int s0 = s1 == s6 ? 12 : s1._size;
object[] s8 = new;
object[] s7 = s1 == s6 ? s8 : s1._items;
return s0 == s7.Length;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 12 : s9._size;
return s8 != 10;
return objs.Length == 12;
Stack s14 = new;
List<object> s15 = new;
List<object> s13 = stack_stack == s14 ? s15 : stack_stack.items;
return methodof(s13.get_Count) == methodof(List<object>.get_Count);
Stack s17 = new;
List<object> s18 = new;
List<object> s16 = stack_stack == s17 ? s18 : stack_stack.items;
return methodof(s16.Add) == methodof(List<object>.Add);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStack.Push at 0x0015"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
int s0 = s1 == s6 ? 12 : s1._size;
return s0 == 10;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
return objs.Length == 12;
Stack s9 = new;
List<object> s10 = new;
List<object> s8 = stack_stack == s9 ? s10 : stack_stack.items;
return methodof(s8.get_Count) == methodof(List<object>.get_Count);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStack.Push at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s1 = new;
Stack s0 = stack == s1 ? stack_stack : stack.stack;
return s0 == (Stack)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length == 13;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStack.Push at 0x0015"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
int s0 = s1 == s6 ? 13 : s1._size;
return s0 == 10;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
return objs.Length == 13;
Stack s9 = new;
List<object> s10 = new;
List<object> s8 = stack_stack == s9 ? s10 : stack_stack.items;
return methodof(s8.get_Count) == methodof(List<object>.get_Count);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.Push at 0x0008"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return methodof(s0.Add) != methodof(List<object>.Add);

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 13 : s9._size;
return s8 != 10;
return objs.Length == 13;
Stack s14 = new;
List<object> s15 = new;
List<object> s13 = stack_stack == s14 ? s15 : stack_stack.items;
return methodof(s13.get_Count) == methodof(List<object>.get_Count);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStack.Push at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s1 = new;
Stack s0 = stack == s1 ? stack_stack : stack.stack;
return s0 == (Stack)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length == 14;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.get_Count at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return methodof(s0.get_Count) != methodof(List<object>.get_Count);

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
return objs.Length == 6;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStack.Push at 0x0015"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
int s0 = s1 == s6 ? 14 : s1._size;
return s0 == 10;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
return objs.Length == 14;
Stack s9 = new;
List<object> s10 = new;
List<object> s8 = stack_stack == s9 ? s10 : stack_stack.items;
return methodof(s8.get_Count) == methodof(List<object>.get_Count);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.get_Count at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return methodof(s0.get_Count) != methodof(List<object>.get_Count);

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
return objs.Length == 2;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.FixedSizeStack.Push at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s1 = new;
Stack s0 = stack == s1 ? stack_stack : stack.stack;
return s0 == (Stack)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return objs.Length == 11;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.get_Count at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return methodof(s0.get_Count) != methodof(List<object>.get_Count);

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
return objs.Length == 7;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.get_Count at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return methodof(s0.get_Count) != methodof(List<object>.get_Count);

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
return objs.Length == 9;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.get_Count at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return s0 == (List<object>)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
return objs.Length == 7;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.get_Count at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return methodof(s0.get_Count) != methodof(List<object>.get_Count);

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
return objs.Length == 11;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: System.Collections.Generic.List`1.Add at 0x000e"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
int s0 = s1 == s6 ? 14 : s1._size;
object[] s8 = new;
object[] s7 = s1 == s6 ? s8 : s1._items;
return s0 == s7.Length;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 14 : s9._size;
return s8 != 10;
return objs.Length == 14;
Stack s14 = new;
List<object> s15 = new;
List<object> s13 = stack_stack == s14 ? s15 : stack_stack.items;
return methodof(s13.get_Count) == methodof(List<object>.get_Count);
Stack s17 = new;
List<object> s18 = new;
List<object> s16 = stack_stack == s17 ? s18 : stack_stack.items;
return methodof(s16.Add) == methodof(List<object>.Add);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.get_Count at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return methodof(s0.get_Count) != methodof(List<object>.get_Count);

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
return objs.Length == 10;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.get_Count at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return methodof(s0.get_Count) != methodof(List<object>.get_Count);

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
return objs.Length == 8;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: System.Collections.Generic.List`1.Add at 0x000e"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s5 = new;
Stack s4 = stack == s5 ? stack_stack : stack.stack;
Stack s3 = s4;
List<object> s6 = new;
List<object> s2 = s3 == (Stack)s5 ? s6 : s3.items;
List<object> s1 = s2;
int s0 = s1 == s6 ? 13 : s1._size;
object[] s8 = new;
object[] s7 = s1 == s6 ? s8 : s1._items;
return s0 == s7.Length;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
Stack s11 = new;
List<object> s12 = new;
List<object> s10 = stack_stack == s11 ? s12 : stack_stack.items;
List<object> s9 = s10;
int s8 = s9 == s12 ? 13 : s9._size;
return s8 != 10;
return objs.Length == 13;
Stack s14 = new;
List<object> s15 = new;
List<object> s13 = stack_stack == s14 ? s15 : stack_stack.items;
return methodof(s13.get_Count) == methodof(List<object>.get_Count);
Stack s17 = new;
List<object> s18 = new;
List<object> s16 = stack_stack == s17 ? s18 : stack_stack.items;
return methodof(s16.Add) == methodof(List<object>.Add);
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.get_Count at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return s0 == (List<object>)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
return objs.Length == 12;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.get_Count at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return s0 == (List<object>)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
return objs.Length == 14;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.get_Count at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return s0 == (List<object>)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
return objs.Length == 10;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.get_Count at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return s0 == (List<object>)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
return objs.Length == 11;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.get_Count at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return methodof(s0.get_Count) != methodof(List<object>.get_Count);

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
return objs.Length == 12;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.get_Count at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return methodof(s0.get_Count) != methodof(List<object>.get_Count);

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
return objs.Length == 13;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.get_Count at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return s0 == (List<object>)null;

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
return objs.Length == 13;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="My Category" title="flipped location: Benchmarks.Stack.get_Count at 0x0007"/>
<dump category="My Category" title="condition"><dtTree><dtTreeNode text="condition"><dtTextNode><rstring contentMode="memory"><![CDATA[FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
Stack s1 = s2;
List<object> s4 = new;
List<object> s0 = s1 == (Stack)s3 ? s4 : s1.items;
return methodof(s0.get_Count) != methodof(List<object>.get_Count);

Feasible prefixes:
Stack s0 = new;
Stack s1 = stack == (FixedSizeStack)s0 ? stack_stack : stack.stack;
return s1 == s0 || stack_stack == s0;
FixedSizeStack s3 = new;
Stack s2 = stack == s3 ? stack_stack : stack.stack;
return s2 != (Stack)null;
return stack != (FixedSizeStack)null;
FixedSizeStack s4 = new;
return stack == s4;
return objs != (object[])null;
return stack_stack != (Stack)null;
Stack s6 = new;
List<object> s7 = new;
List<object> s5 = stack_stack == s6 ? s7 : stack_stack.items;
return s5 != (List<object>)null;
return objs.Length == 14;
]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<coverage domain="usercodeundertest" unit="block" covered="6" total="8" coveredRatio="0.75"/>
<sourceCoverage xml="cov\e299\cov.xml" html="cov\e299\cov.html"/>
<result name="TestPush(FixedSizeStack, Object)" state="failed" duration="5.4935746269224"/>
<duration start="2015-11-27 23:30:27Z" end="2015-11-27 23:30:35Z" seconds="7.3675716"/>
</exploration>
<coverage domain="usercodeundertest" unit="block" covered="6" total="8" coveredRatio="0.75"/>
<sourceCoverage xml="cov\t97\cov.xml" html="cov\t97\cov.html"/>
<duration start="2015-11-27 23:30:27Z" end="2015-11-27 23:30:35Z" seconds="7.481106"/>
</fixture>
<dump category="test" title="test"><dtTree><dtTreeNode text="test"><dtTextNode><rstring contentMode="memory"><![CDATA[methods: 15]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.FixedSizeStackTest.TestPush/1 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.FixedSizeStackTest.TestPush/2 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.FixedSizeStackTest.TestPush/1 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.FixedSizeStackTest.TestPush/2 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.FixedSizeStackTest.TestPush/1 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.FixedSizeStackTest.TestPush/2 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.FixedSizeStackTest.TestPush/1 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.FixedSizeStackTest.TestPush/2 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.FixedSizeStack.Push/2 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.FixedSizeStack.Push/3 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.FixedSizeStack.Push/2 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.FixedSizeStack.Push/3 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.FixedSizeStack.Push/2 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.FixedSizeStack.Push/3 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.FixedSizeStack.Push/2 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.FixedSizeStack.Push/3 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.FixedSizeStack.Push/7 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.FixedSizeStack.Push/8 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.FixedSizeStack.Push/7 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.FixedSizeStack.Push/8 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.FixedSizeStack.Push/7 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.FixedSizeStack.Push/8 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.FixedSizeStack.Push/10 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.FixedSizeStack.Push/12 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.FixedSizeStack.Push/13 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.FixedSizeStack.Push/12 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.FixedSizeStack.Push/13 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.FixedSizeStack.Push/12 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.FixedSizeStack.Push/13 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.FixedSizeStack.Push/12 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.FixedSizeStack.Push/13 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.Stack.get_Count/2 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.Stack.get_Count/3 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.Stack.get_Count/2 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.Stack.get_Count/3 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.Stack.get_Count/2 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.Stack.get_Count/3 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.Stack.get_Count/2 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.Stack.get_Count/3 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.Stack.Push/2 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.Stack.Push/3 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.Stack.Push/2 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.Stack.Push/3 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.Stack.Push/2 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.Stack.Push/3 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.Stack.Push/2 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: Benchmarks.Stack.Push/3 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: System.Collections.Generic.List`1.Add/2 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: System.Collections.Generic.List`1.Add/2 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: System.Collections.Generic.List`1.EnsureCapacity/5 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: System.Collections.Generic.List`1.EnsureCapacity/5 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: System.Collections.Generic.List`1.set_Capacity/2 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: System.Collections.Generic.List`1.set_Capacity/2 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: System.Collections.Generic.List`1.set_Capacity/6 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: System.Collections.Generic.List`1.set_Capacity/7 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: System.Collections.Generic.List`1.set_Capacity/6 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: System.Collections.Generic.List`1.set_Capacity/7 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: System.Collections.Generic.List`1.set_Capacity/9 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: System.Collections.Generic.List`1.set_Capacity/9 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: __InstrumentedSummarizers.System.Array.Copy/2 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: __InstrumentedSummarizers.System.Array.Copy/3 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: __InstrumentedSummarizers.System.Array.Copy/2 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: __InstrumentedSummarizers.System.Array.Copy/3 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: __InstrumentedSummarizers.System.Array.Copy/2 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: __InstrumentedSummarizers.System.Array.Copy/3 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: __InstrumentedSummarizers.System.Array.Copy/5 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: __InstrumentedSummarizers.System.Array.Copy/7 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: __InstrumentedSummarizers.System.Array.Copy/8 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: __InstrumentedSummarizers.System.Array.Copy/7 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: __InstrumentedSummarizers.System.Array.Copy/8 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: __InstrumentedSummarizers.System.Array.Copy/7 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: __InstrumentedSummarizers.System.Array.Copy/8 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: __InstrumentedSummarizers.System.Array.Copy/10 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: __InstrumentedSummarizers.System.Array.Copy/11 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: __InstrumentedSummarizers.System.Array.Copy/12 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: __InstrumentedSummarizers.System.Array.Copy/14 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: __InstrumentedSummarizers.System.Array.Copy/15 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: __InstrumentedSummarizers.System.Array.Copy/14 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: __InstrumentedSummarizers.System.Array.Copy/15 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: __InstrumentedSummarizers.System.Array.Copy/14 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: __InstrumentedSummarizers.System.Array.Copy/15 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: __InstrumentedSummarizers.System.Array.Copy/17 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<dump category="coverage" title="coverage"><dtTree><dtTreeNode text="coverage"><dtTextNode><rstring contentMode="memory"><![CDATA[CodeBranch: __InstrumentedSummarizers.System.Array.Copy/18 is not explicit]]></rstring>
</dtTextNode>
</dtTreeNode>
</dtTree>
</dump>
<coverage domain="usercodeundertest" unit="block" covered="6" total="8" coveredRatio="0.75"/>
<sourceCoverage xml="cov\a14317408\cov.xml" html="cov\a14317408\cov.html"/>
<duration start="2015-11-27 23:30:27Z" end="2015-11-27 23:30:35Z" seconds="7.6176176"/>
<frameTreeRef exceptionCount="2"/>
</assembly>
<duration start="2015-11-27 23:30:26Z" end="2015-11-27 23:30:35Z" seconds="8.4083036"/>
<background/>
</pex>
